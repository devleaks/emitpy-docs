{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Airport Opera","text":"<p>Airport Opera is a software application that estimate the operational effectiveness of an airport.</p> <p>Airport Opera proceeds from observation of aircrafts and ground support vehicles movements. From observations, quantified observables are created and constantly monitored. They are compared to past values, providing an array or possible trends and evolutions of a current situation.</p>"},{"location":"#emitpy-adsb-track-generator","title":"Emitpy: ADS\u2013B Track Generator","text":"<p>To help develop Airport Opera, emitpy is a ADS-B track generator that simulates aircrafts and ground support vehicles ADS-B message broadcasts. It is used to generate deterministic sets of data for development purposes. Since artificially generated, sets of data can exhibit challenges and controlled behaviours to developers.</p>"},{"location":"emitpy/Emitpy%20App/","title":"Steps for each do_ function","text":"<p>(do_flight, do_service, do_flight_services, do_mission)</p> <ol> <li>Collect data</li> <li>Create flight/mission/service\u2026</li> <li>Create move</li> <li>(save move?)</li> <li>Create emit</li> <li>Schedule emit</li> <li>(save emit?)</li> <li>Schedule messages</li> <li>(save messages?)</li> <li>Create format + format</li> <li>(save format?)</li> <li>Format messages</li> <li>(save format messages)</li> <li>Enqueue positions</li> <li>Enqueue messages</li> <li>Done + summary</li> </ol>"},{"location":"emitpy/Emitpy%20App/#steps-for-each-re-schedule-function","title":"Steps for each re-Schedule function","text":"<ol> <li>Create ReEmit (this will also create ReMessages)</li> <li>Schedule emit</li> <li>(save emit?)</li> <li>Schedule messages</li> <li>(save messages?)</li> <li>Create format + format</li> <li>(save format?)</li> <li>Format messages</li> <li>(save format messages)</li> <li>Enqueue positions (this will remove old emissions)</li> <li>Enqueue messages (this will remove old messages)</li> <li>Done + summary</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20ADS-B%20Track%20Generator/","title":"Home","text":"<p>Emitpy is a supporting software for the Airport Opera project.</p> <p>The goal of the Airport Opera project is to non-invasively monitor an airport from ADS-B messages produced by aicrafts and airport ground support vehicles.</p> <p>Emitpy generates synthetic ADS-B messages as they would be produced by ADS-B emitter(s) like, in the context of airports, aircrafts and airport ground support vehicles. Emitpy generates such messages in a highly realistic way.</p> <p>The primary goal is to produce sets of reproducible, deterministic, realistic ADS-B data (or \u00abmessages\u00bb) for software that process or use them, for development purpose. The generated data is developer controlled and can exhibit particular properties or challenges to developers.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20ADS-B%20Track%20Generator/#the-managed-airport","title":"The Managed Airport","text":"<p>The core entity of emitpy is the airport being managed, aptly called the \u00abManaged Airport\u00bb. Emitpy will generate artificial activity on the ground of that airport.</p> <p>There are two types of track data that can be produced on the ground of that airport: 1. Aircraft tracks (taxi, takeoff, landing, tow\u2026) 2. Ground support vehicle tracks</p> <p>Aircraft tracks are generated for both arrival and departure flights. In either case, the flight is simulated to/from the Managed Airport from/to the remote airport. The generated flight path is realistic, it follows airport terminal procedures and routes; vertical navigation is respected; on the ground taxi in and out is simulated to/from a parking position from/to the runway.</p> <p>Ground support vehicle tracks are generated for a selected number of service vehicles (fuel, catering, pushback, etc.). Ground vehicles move on airport service roads. They are scheduled to serve aircraft turnaround operations. When an aircraft reaches a parking, a small fleet of service vehicles will move towards the aircraft to provide their services, and leave their position when done. Baggage trolleys, for example, will run back and forth between the side of the aircraft to the baggage processing area.</p> <p>Finally, emitpy provides a sophisticated mechanism to broadcast those ADS-B messages on one or more output queues in a time-controlled way.</p> <p>Start a tour of the emitpy application with the central entity, the Managed Airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/","title":"Core Entities","text":"<ol> <li>The Managed Airport</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/#flight","title":"Flight","text":"<ol> <li>Aerospace<ol> <li>Navaids and fixes</li> <li>Airways</li> <li>Airspaces</li> <li>Airport (terminals)</li> <li>Terminal Procedures</li> <li>Runways</li> <li>Taxiways</li> <li>Ramps</li> <li>Aeroway Points of Interest (POI): Runway exit, taxi hold positions.</li> </ol> </li> <li>Aircraft</li> <li>Flight</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/#ground-support","title":"Ground Support","text":"<ol> <li>Service</li> <li>Equipment</li> <li>Flight Service</li> <li>Turnaround</li> <li>Mission</li> <li>Ramp Service Point Profile</li> <li>Service roads</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/#movement","title":"Movement","text":"<ol> <li>Movement</li> <li>Message</li> <li>Emit, Schedule, Format</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/#communication-and-broadcast","title":"Communication and Broadcast","text":"<ol> <li>Broadcast: Queue and Formatting</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20All%20Entities/#notes","title":"Notes","text":"<p>A few real-life objects or concepts exist and are represented by different entities depending on their function in emitpy.</p> <p>For example, an airport is represented as - a geographic named entity called an Airport (latitude, longitude, altitude, time zone, city, country), - a aeronautical named entity called a Terminal (CIFP procedures, available runways\u2026).</p> <p>Similarly, an airport runway is represented as - a named geographic entity (either a line or a polygon surface) called a Runway, - a named aeronautical entity (heading, length\u2026) called RWY, - a resource (usage, time slots), called a RunwayResource. (When grouped in collections, containers wear names like <code>runways</code> , <code>rwys</code>, or <code>resource</code> to distinguish between the two.)</p> <p>A ramp is represented as - a named geographic entity (lat, lon, heading) called a Ramp, - a resource (allocation, time slots).</p> <p>Often, if convenient, both entities are linked together.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Configuration/","title":"Emitpy \u2013 Configuration","text":"<p>The hardest part when using Emitpy is to collect all necessary data it\u2019s needs to run properly.</p> <p>Data consists of:</p> <p>(Globally)</p> <ul> <li>Airspace data ranking from waypoints, fixes, and airways, to airport flight procedures.</li> </ul> <p>(For the Managed Airport)</p> <ul> <li>Networks of taxiways and service roads,</li> <li>Point of interest with Emitpy naming convention,</li> </ul> <p>Optionally, for more realism:</p> <ul> <li>Weather information source (METAR, TAF, grib2 files\u2026)</li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/","title":"Data Sources","text":"<p>Emitpy needs miscellaneous information for creating realistic flights or ground support vehicle movements.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#aerospace","title":"Aerospace","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airports","title":"Airports","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airports_1","title":"Airports","text":"<p>Airport need the following mandatory information:</p> <ul> <li>Name</li> <li>Municipality</li> <li>Country</li> <li>Aeronautical region</li> <li>latitude, longitude, and optionally altitude</li> <li></li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#coded-instrument-flight-procedures","title":"Coded Instrument Flight Procedures","text":"<p>If part of a flight, it is more realist of CIFP are available at the remote airport. CIFP are mandatory at the managed airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#navigation","title":"Navigation","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#navigation-aids","title":"Navigation Aids","text":"<p>Navaids need the following mandatory information:</p> <ul> <li>Name or Identifier</li> <li>Aeronautical region</li> <li>Type of Navaid</li> <li>latitude, longitude, and optionally altitude</li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#fixes","title":"Fixes","text":"<p>Fixes need the following mandatory information:</p> <ul> <li>Name or Identifier</li> <li>Aeronautical region</li> <li>latitude, longitude</li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airways","title":"Airways","text":"<ul> <li>Name or Identifier</li> <li>Aeronautical region</li> <li>Starting and ending navaid or fix</li> <li>Restrictions (one way, upper or lower airway\u2026)</li> <li></li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airspaces","title":"Airspaces","text":"<ul> <li>Name or Identifier</li> <li>Aeronautical region</li> <li>Restriction(s)</li> </ul>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#managed-airport","title":"Managed Airport","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airspace","title":"Airspace","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#cifp","title":"CIFP","text":"<p>Arrival and departure procedure should be available at the managed airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#taxiways","title":"Taxiways","text":"<p>The network (topology) of taxiways is necessary to route aircrafts to runways and parking positions.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#ramps","title":"Ramps","text":"<p>Ramps are locations where aircraft stops for servicing. A ramp has an orientation.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#service","title":"Service","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#service-road-network","title":"Service Road (Network)","text":"<p>The network (topology) of service roads available to ground handling/support vehicle (GSE) is necessary to have them move on that network when travelling on the ground of the airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#depots","title":"Depots","text":"<p>A Depot is a special area where GSE go to do some processing with their duties. For example, it is a fuel depot where fuel tank truck go for refill, or a baggage handling terminal area where baggage trolley load or unload baggages.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#gse-parkings","title":"GSE Parkings","text":"<p>GSE Parkings are special area where GSE vehicle go when not used.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#business","title":"Business","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#ground-support-equipment","title":"Ground Support Equipment","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#fleet-of-gse","title":"Fleet of GSE","text":"<p>Determine how many vehicle of which types are available for aircraft servicing.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#flight-services","title":"Flight Services","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#arrival-and-departure-services","title":"Arrival and Departure Services","text":"<p>Determine the list of services performed after an arrival or before a departure. Also specifies when the service occurs, relative to the arrival or departure times.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#others","title":"Others","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#aircraft","title":"Aircraft","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#aircraft-types","title":"Aircraft Types","text":"<p>List of possible aircraft types for flights.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#aircraft-performances-bada","title":"Aircraft Performances (BADA)","text":"<p>Aircraft performances for each of the above type.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#data-locations","title":"Data Locations","text":"<p>Data like Aerospace data and aircraft performances are available throughout the application.</p> <p>Data like managed airport airways, taxiways, service roads, aircraft service tasks and schedule, but also operating airlines, flight tables, etc. are specific to the managed airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#reference-data","title":"Reference Data","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#global-data","title":"Global Data","text":"<p>Aircraft types Aircraft performances Aircraft Ground Support Requirements (profile) Aircraft classes</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#aerospace-data","title":"Aerospace Data","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airports_2","title":"Airports","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#flexible-data","title":"Flexible Data","text":"<p>Flexible data can be aquired from different sources.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airspaces_1","title":"Airspaces","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#navaids-and-fixes","title":"Navaids and fixes","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airways_1","title":"Airways","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#cifp_1","title":"CIFP","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#managed-airport-data","title":"Managed Airport Data","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#cfip","title":"CFIP","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#runways","title":"Runways","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#taxiways_1","title":"Taxiways","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#ramps_1","title":"Ramps","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#service-roads","title":"Service roads","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#operational-data","title":"Operational Data","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#companies","title":"Companies","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#airlines","title":"Airlines","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#handlers","title":"Handlers","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#operators","title":"Operators","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#services","title":"Services","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#service-types-and-schedule","title":"Service Types and Schedule","text":"<p>Arrival/departure Passenger/cargo Jetway/Tie-down</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#service-vehicle-fleet","title":"Service Vehicle Fleet","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Data%20Sources/#flight-tables","title":"Flight Tables","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/","title":"Emitpy \u2013 From the Command Line","text":"<p>The following note is a description of the steps needed to use Emitpy effectively.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/#initialisation","title":"Initialisation","text":"<p>When using Emitpy, the first step is to create the environment where vehicle movements will be created. This consists of - Initiating the Aerospace where flights will occur, - Initiating the Managed Airport where ground support vehicle will move, - Selecting a few options regarding the environment, like the source of weather information if desired. This has to be done once, the environment will be used over and over again afterwards.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/#flight-elements","title":"Flight Elements","text":"<p>Before we can create a flight, we have to collect all elements necessary for it. - Airports, one of which will be the Managed Airport, - Aircraft, from its aircraft type, - Local details like parking ramp and/or gate, - General flight informations like flight level and cruise speed,</p> <p>If necessary, it also is possible to enforce one or more flight procedures used at each airport.</p> <p>When all data is collected, a new flight can be created.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/#flying","title":"Flying","text":"<p>When the flight has properly been created, it can proceed with its movement, it\u2019s scheduling, and ultimately, the production of ADS-B messages that will be emitted during the flight.</p> <p>Later, the flight can be rescheduled.</p> <p>At this stage, it is not possible to change a flight data or parameter once it is created. A new flight has to be created.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/#ground-service","title":"Ground Service","text":"<p>Once a flight has been created and scheduled, it is possible to create and schedule all services at the managed airport.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20From%20the%20Command%20Line/#learning","title":"Learning","text":"<p>At the root of the source code of Emitpy, there are two scripts that can be used to learn how to create flights with Emitpy.</p> <p><code>Loadapp.py</code> is a script that loads data from Emitpy and save it to a Redis database (simple key, value store).</p> <p><code>Emitapp.py</code> is a script that chains necessary operations to create flights and ground support services.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Randomization/","title":"Emitpy \u2013 Randomization","text":"<p>At the current stage of development, there is little randomization of parameter selection. However, there are enough randomization already to prevent exact reproduction execution.</p> <p>Some randomness is brought by the weather forecast that changes. If historical weather is not found, current weather is used, and weather changes\u2026</p> <p>Even with constant weather or no weather, randomness is present. If there is no wind, a random direction for takeoff is selected, often, a random SID (towards the overall destination) is also selected. At the arrival, similar random selections occur.</p> <p>Randomness can also occur when some values cannot be found. For example, if a ramp is not provided for a flight, a random ramp at the airport is selected.</p> <p>These choice make exact reproduction of generated track almost impossible.</p> <p>However, experimentally, whenever a failure occurs during track generation, it will more than probably occur again later. By accumulating failing generations, a trend will appear and allow for code adjustment.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Randomization/#the-future-of-randomness","title":"The Future of Randomness","text":"<p>Randomness can be brought at numerous stage in the simulation.</p> <ol> <li>Random destination (expand flight routes!)</li> <li>Random delays in all timing: flights, services, etc.</li> </ol>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/","title":"Emitpy \u2013 Usage Exemple","text":"<p>Practically, currently, the Emitpy generator can be used from two end points.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#python-emitapp-class","title":"Python EmitApp Class","text":"<p>First, there is a wrapping EmitApp python class that loads all necessary entities and offer a limited number of entry points to generate flights and ground support equipment movements.</p> <ul> <li>do_flight</li> <li>do_service</li> <li>do_flight_service</li> <li>do_schedule</li> <li>do_mission</li> </ul> <p>And their deletion counter parts</p> <p>All function parameters are strings.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#rest-api","title":"REST API","text":"<p>As an alternative to this python class that can directly be used in python scripts (numerous examples are provided in the <code>bin</code> directory), Emitpy proposes a very simple direct REST API to execute the very same calls. The REST API also has numerous information end points to get, for example, a list of valid aircraft type or fuel vehicle models. Those information end points can be used to build user interfaces. A Postman file has example of API call and there is also a script of direct calls to the API to exemplify its use. </p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#examples","title":"Examples","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#single-flight","title":"Single Flight","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#turnaround","title":"Turnaround","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#flight-table","title":"Flight Table","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#day-activity","title":"Day Activity","text":""},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#practical-use","title":"Practical Use","text":"<p>The original design goal of Emitpy was to generate the difficult to get ADSB-B messages. Emitpy was created to artificially generate those messages. To do so, the idea is to proceed as follow: 1. When the flight board is available, arrival and departure flights can be created as scheduled. Creation can proceed until emission points are ready to be used. 2. When some estimated or actual position is received for a flight, for example, when the aircraft took off, or when we receive and ACARS message, or when we receive an ETA, etc. we can take the set of emission points generated at step 1 above and schedule them to fit the received position, to fit the reality. 3. ADS-B messages will be enqueued by Emitpy as they would be produced by the aircraft and capture by a local ADS-B message receiver. They can be processed and used like real messages.</p>"},{"location":"emitpy/Emitpy%20%E2%80%93%20Usage%20Exemple/#possible-failure","title":"Possible Failure","text":"<p>Here are the most common reasons for failure:</p> <ol> <li>Non existant airport (changed, new, abandoned, due to discrepency between flights, flight tables, and aeronautical databases used.)</li> <li>Invalid METAR or TAF message (failure to fetch data, failure to parse returned data)</li> <li>No route found for a flight using airways.</li> <li>No route found for a service vehicle on service road network.</li> </ol> <p>Sometimes, simply re-submitting the same request will work without error, probably because some random combinations of parameters have caused the issue.</p> <p>We have a set of ~250,000 movements that we generated with Emitpy. Statistically, more than 92% of generation succeed. It is rare to find a failure not enumerated above.</p>"},{"location":"emitpy/Programming%20Notes/","title":"Geospatial Data Handling","text":"<p>If you are looking for a \"pure python\", well, as pure as you can get, for basic geospatial options, please head for <code>pyturf</code> (turfpy) rather than other GeoJSON and turf python packages.  Pyturf includes GeoJSON helper class and functions that respect the <code>__geo_interface</code> specification. Pyturf is very pythonic, use simple pytest, is how any python package should be. I took me an entire day to switch from geojson/turpy to pyturf.</p>"},{"location":"emitpy/Programming%20Notes/#yaml-rather-than-json","title":"Yaml rather than JSON","text":"<p>If possible, Yaml files are so much easier to read. Yaml is a superset of JSON, which means that all JSON files are valid Yaml files and can be read and processed by Yaml readers. I wish GeoJSON be GeoYaml and pyturf accept GeoYaml. This can easily be done thanks to tiny wrappers.</p>"},{"location":"emitpy/To%20Do/","title":"To Do","text":""},{"location":"emitpy/To%20Do/#maintain-bi-directional-like-between-resource-and-linked-object","title":"Maintain bi directional like between resource and linked object.","text":"<p>ramp.resource = Resource(resource=ramp)</p> <p>resource.name = resource.getId() resource.resource = resource</p> <p>Check link flight &lt;-&gt; {services}</p>"},{"location":"emitpy/To%20Do/#ideas-to-do","title":"Ideas, To do","text":"<p>Services: If no start position, use (closest) depot If no end position, use ramp rest position</p> <p>G\u00e9p\u00e8s Cidesimal, geospatial specialist, &amp; Nafis Atou Ahouiyassa, developer, &amp; Hessa Hamplis, developer.</p>"},{"location":"emitpy/To%20Do/#future-releases-names","title":"Future releases names","text":"<p>17: La M\u00e9duse 18: Indomptable 19: Achille 20: Redoutable Scilly naval disaster of 1707</p> <p>Read from file/dict, not Redis Redis only if queue?</p> <p>service-pois: when loading, check that each service has at least 1 depot, 1 parking. if not: either suppress service or add depot and/or parking at airport's center.</p> <p>simplify aircraft types to narrow-body, wide-body? add turnaround profiles for them</p> <p>Correct: LoadAirlines in loadapp to load flight operators as well</p> <p>Ramp: Add: hasJetway()</p> <p>Flight: Add cargo/pax + service choice, shortcut: cargo flight are not Jetway</p> <p>May be add a rule in airport to tell whether Ramp has jetway?</p> <p>airport.hasJetway(ramp) -&gt; bool based on list of ramp with jetways, supplied in airport.yaml?</p>"},{"location":"emitpy/To%20Do/#to-do","title":"To do","text":"<p>add pax/cargo to API make some parameters optionals runway not used?</p> <p>create arbitrary event</p> <p>logger.(debug|info|warn|warning|error)(([f'\"]*):([a-zA-Z0-9_]+): </p> <p>Add optional flight_id to Service?</p> <p>Add alternate label to Service, use service label in service messages rather than service name/type.</p> <p>check for cargo and baggage that trolley travels back and forth between ac and depot.</p> <p>May be review class hierarchy, making movement and emit traits rather than autonomous classes.</p> <p>When scheduled time changed, adjust resource times.</p> <p>Long term: Think \"interfaces\" like <code>__geo_interface__</code> for objects. Make a visible object like traffic for flights, etc.</p> <p>Better isolate flight plan</p> <p>Next airports</p> <p>FRA (EDDF) MUN (EDDM) AMS (EHAM)</p> <p>EBBR OMDB (OTBD)</p>"},{"location":"emitpy/Airport/Airport%20Manager/","title":"Airport Manager","text":"<p>The Airport Manager is a containing entity that is responsible for managing resources used by the simulation.</p> <p>The Airport Manager contains</p> <ul> <li>The fleet of service vehicles, grouped by service vehicle types (catering, fuel, etc.), their usage and availability for service,</li> <li>All ramp allocations for turnaround operations,</li> <li>All runways allocations for take-offs and landings.</li> </ul> <p>It registers usage of resources like runways, ground vehicles or ramps.</p> <p>The Airport Manager also contains reference data for the simulation:</p> <ul> <li>Operating airlines and their air routes to/from the Managed Airport</li> <li>A directory of all companies operating at the Managed Airport (airlines, handlers, or other services like firefighting, custom, or police.)</li> </ul> <p>Resource allocation can be changed, however, there is no check that the new requested times are available for the resources. A resource scheduler is a complex software on its own and we could not find one to use with Emitpy.</p>"},{"location":"emitpy/Airport/Airport/","title":"Airport","text":"<p>In its simplest form, an Airport is a localized named entity. It contains:</p> <ul> <li>Its position (lat, lon, alt)</li> <li>Its administrative location (city, country)</li> <li>Its timezone</li> </ul>"},{"location":"emitpy/Airport/Airport/#airportwithprocedures","title":"AirportWithProcedures","text":"<p>In a more complex form, an airport can be fit with its Coded Instrument Flight\u00a0Procedures. Procedures include:</p> <ul> <li>Runways</li> <li>Standard Instrument Departure Procedures (SID)</li> <li>Standard Terminal Arrival Procedures (STAR)</li> <li>Approaches (APPCH)</li> </ul> <p>Sometimes, noticeable transitions are also included.</p>"},{"location":"emitpy/Airport/Airport/#managed-airport-base","title":"Managed Airport Base","text":"<p>In its most complex form, an airport references all additional data necessary to qualify as a Managed Airport.</p> <p>The Managed Airport Base is an abstract class that can be used as the base of Managed Airport. Realisation of the abstract class are responsible for loading and providing necessary data. A Managed Airport must contain the following data:</p> <ul> <li>Runways</li> <li>Network of taxiways</li> <li>Ramps</li> <li>Network of service roads</li> <li>Points of interest like parkings, and depots.</li> </ul> <p>This data can be aquired from different sources.</p>"},{"location":"emitpy/Airport/Managed%20Airport/","title":"Managed Airport","text":"<p>The Managed Airport represents the airport that Airport Opera will monitor. Emitpy will simulate activity on the ground of that airport, and generate location messages as they would be produced by vehicles on the ground or captured by ground radar equipments.</p> <p>The Managed Airport is a container entity. It is responsible for loading and sharing common structures.</p> <p>A first set of entities is necessary to create and simulate aircraft movements:</p> <ul> <li>The entire \u00abAerospace\u00bb as used in the application,</li> <li>All airports,</li> <li>Airlines, and other operators and handlers,</li> <li>All aircraft types that can be used in the application.</li> </ul> <p>It then loads entities specific to the managed airport, all contained in a \u00abManaged Airport Base\u00bb:</p> <ul> <li>Flight procedures for departures and arrivals</li> <li>Runways</li> <li>Taxiways</li> <li>Ramps</li> <li>Aprons</li> <li>Service road network, including parking areas</li> <li>Points and areas of interest on the ground of the airport and around</li> </ul> <p>A Weather Engine is created to fetch airport and en-route weather and forecasts.</p> <p>Finally, it initialise the \u00abAirport Manager\u00bb, another containing entity responsible for airport resource allocation and monitoring:</p> <ul> <li>Runway usage,</li> <li>Ramp occupancies,</li> <li>Equipment and service vehicle use.</li> </ul> <p>Once all components are loaded, Emitpy is ready to create flights and services.</p>"},{"location":"emitpy/Broadcast/Broadcast/","title":"Broadcast","text":"<p>Optionally, emitted messages are published on a timely fashion on output queues. This process is called the Broadcast.</p> <p>The broadcast process is a sophisticated output mechanism that proposes messages on one or more output queue. The model of a queue is a source of data for aircraft and/or vehicle location. In an airport environment, we can for exemple have an output queue for each ground radar, and an output queue for ADS-B messages fetched from an ADS-B supplier or a few inexpensive local Raspberry Pi computers listening for local ADS-B messages.</p> <p>Currently, the output queue is realized by a Redis Publish/Subscribe Queue (one or more queues are possible).</p>"},{"location":"emitpy/Broadcast/Broadcast/#output-queue","title":"Output Queue","text":""},{"location":"emitpy/Broadcast/Broadcast/#name","title":"Name","text":"<p>The output queue has a name, used to designate the rendez-vous for message subscription.</p>"},{"location":"emitpy/Broadcast/Broadcast/#start-time","title":"Start Time","text":"<p>The optional start time of a queue is the time at which the queue will start emitting messages. It can be a time in the past or in the future. Default is to use the current time. When the start time of a queue is changed, the queue is reset. </p>"},{"location":"emitpy/Broadcast/Broadcast/#speed","title":"Speed","text":"<p>The speed of emission can be adjusted to accelerate or slow down emissions. The default value is 1, which means that time flows at normal speed, 1 second last 1 second. It is possible to slow down the broadcast of messages by supplying a speed smaller than 1. A speed of 0.1 will make 1 simulated second last 10 real second. This is very useful if events arrive at very high rate. Inversely, a speed of 60 (the maximum) will make a simulated minute last 1 real second. This can be used to artificially increase the event emission rate or speed up the simulation. The speed of a queue can be changed any time.</p>"},{"location":"emitpy/Broadcast/Broadcast/#queue-reset","title":"Queue Reset","text":"<p>When reset, the emission time of the queue is reset at its start time. When the start time of a queue is changed, the queue is reset.</p> <p>For convenience reason, the queue regularly broadcast its simulated time together with the real time.</p>"},{"location":"emitpy/Broadcast/Broadcast/#emission-re-submission","title":"Emission Re-Submission","text":"<p>When a message is sent, it is removed from a queue and lost after its emission. However, if a particular movement (or set of movements) needs to be played back, it is always possible to enqueue the emissions of those movements again for broadcast, starting from a saved position, without redoing any calculation. When enqueueing a movement again, it is possible to reschedule it at another time as well.</p>"},{"location":"emitpy/Broadcast/Broadcast/#broadcaster","title":"Broadcaster","text":"<p>The Broadcaster is a process that schedule the emission of messages in a queue based on message timestamp and queue properties (start time and speed). There is a broadcaster process for each queue.</p>"},{"location":"emitpy/Broadcast/Broadcast/#hypercaster","title":"Hypercaster","text":"<p>The Hypercaster process is a process that manages all broadcasters. When a new queue is created, the Hypercaster starts a new broadcaster process for it. When a queue is deleted, the Hypercaster process stops and destroy the associated broadcaster  process. When the emitpy application starts, the Hypercaster process starts all broadcaster processes. When the emitpy application terminates, the Hypercaster gracefully terminates all queues.</p>"},{"location":"emitpy/Broadcast/Broadcast/#usage","title":"Usage","text":"<p>Usages of the flexible broadcast mechanism are multiple.</p> <p>It possible to start from a existing simulation, and accelerate time to foresee what the situation will be in a near future.</p> <p>It is possible to replay past situation, even slow them down to see how a particular process evolved. It is possible to replay the same situation over and over again.</p> <p>The enqueuing of a movement does not rely exclusively on the simulation. It is possible to save, format, and enqueue messages coming from other sources and using the broadcaster to replay the situation and analyze it.</p> <p>By speeding up queue emission, it is possible to generate higher broadcast rates to stress test system performances.</p>"},{"location":"emitpy/Broadcast/Broadcast/#default-queues","title":"Default Queues","text":"<p>When started, the broadcaster always creates two default queues called <code>raw</code> and <code>wire</code>. - Raw queue receives reported positions from Emitpy. - Wire queue receives messages from Emitpy.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/","title":"Emit, Schedule, Format","text":"<p>A movement is a time-ordered collection of positions that represent the displacement of a vehicle. Each position is associated with properties like speed of the vehicle at the position. Geometry-wise, it can be considered as a augmented LineString. A movement has no absolute time. All times in a movement are relative to the start of the movement. A movement can then be scheduled to occur at any time. The movement will never change, only the time at which it occurs. Deciding the time at which the movement will occur is the purpose of the movement scheduling.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#emit","title":"Emit","text":"<p>The Emission of a Movement is the process of creating an alternate movement representation that follow the exact same path, but where position points are equality distant in time, the difference in time between two position is always the same. That difference in time between two positions is called the emission time.</p> <p></p> <p>The resulting path is called the Emit. Very much like a flight movement, an Emit is not time dependant. Each point occurs the same time period after the preceding one. Deciding the time at which the emission will occur is the purpose of the emission scheduling.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#emit-frequency","title":"Emit Frequency","text":"<p>Emit is the process of broadcasting position information for a Movement at regular time interval. Emit starts from a Movement. It follows the movement, taking into account the movement times and speeds, and insert emission marks at regular time interval. The time interval is a parameter of the Emit process. It can be as frequent as every second, or as infrequent as every 10 or 30 minutes. The result of the Emit process is a new collection of time-ordered positions, positions where the emission of the position will occurs. Geometry-wise, it can be considered as another LineString where there is exactly the same time interval between each position if we consider that the LineString represents a movement of a vehicle.</p> <p>The same movement can be emitted several times with different emission parameters.</p> <p>The result of Emit, the new LineString, is also time-relative, with the time zero at the beginning of the Movement.</p> <p>The Movement LineString and the Emit LineString have the same path in space.</p> <p>During the Emit process, Marks are preserved with their precise time and location.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#emit-frequency-limit","title":"Emit Frequency Limit","text":"<p>When the emit frequency is higher than every 10 seconds, emission will only occur if the vehicle is in the vicinity of the Managed Airport. Typically, when simulating the echo of a radar ping, ground radar broadcast the position of vehicle every second. This can produce a significant amount of data, both during the movement and emission generation process and during the broadcast of the messages on an output queue. Example: - 8 moving aicrafts, and - 20 parked aircrafts all being services by 4 service vehicles each, approximately generate 100 messages per second. For a intercontinental 8 hour flight, we will not generate positions every second. We will only generate positions every second if the aircraft is less than 3 or 5 nautical miles from the simulated radar of the managed airport.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#scheduling","title":"Scheduling","text":"<p>Scheduling is the process of setting an absolute time of emission for each Emit. To schedule an Emit, it is necessary to supply a Mark and the date/time at which the Mark is reached. For example, for a flight, we can schedule the emission such that the touch-down time is a very precise date/time. For a service, we can schedule de service such as the end of the service terminates 15 minutes before the departure time.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#format","title":"Format","text":"<p>The Format process generates the simulated message from data avaialble in emitpy. In the course of building the movement, data is accumulated at each point: position, speeds, timing information, aircraft used, service vehicle type\u2026 A standard ADS-B message does not contain all this data. There is a step to select which data will be broadcast, and in which format. That process is called the Formatting.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#default-format","title":"Default Format","text":""},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#default-format-for-positions","title":"Default Format for Positions","text":"<p>The default format is text, each point is published as a GeoJSON Feature point with all data as name,value pair properties. This format is called <code>raw</code>. Structured properties can optionally be flattened into a simpler (name, value) structure. In this case, the format is called <code>flat</code>.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#default-format-for-messages","title":"Default Format for Messages","text":"<p>The default format for Messages is text. A dictionary of (name, value) pairs published as a JSON text string.</p> <p>Formatted messages are then stored for later broadcast.</p>"},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#re-schedule","title":"Re-Schedule","text":""},{"location":"emitpy/Broadcast/Emit%2C%20Schedule%2C%20Format/#reemit","title":"ReEmit","text":"<p>When an Emit is rescheduled, absolute emission times are changed but all other attributes are unaffected. A ReEmit loads an existing Emit (from a file or from Redis database) and re-schedule it. If the emission was enqueued for broadcast, emission points with the old schedule are removed first and the new scheduled points are enqueued.</p> <p>The same applies to accompagnying Messages that are re-scheduled accordingly. See  ReMessage.</p>"},{"location":"emitpy/Broadcast/File%20Output/","title":"File Output","text":"<p>In its simplest form, Emitpy can optionally save each step of the emission creation process into files.</p> <p>For flights:</p> <ul> <li>Flight Route</li> <li>Flight Movement</li> <li>Emission (Unscheduled)</li> <li>Scheduled and formatted (final) emission</li> </ul> <p>For services:</p> <ul> <li>Service Movement</li> <li>Emission (Unscheduled)</li> <li>Scheduled and formatted (final) emission</li> </ul> <p>When using a Redis database, outputs are saved in Redis variables. (The Redis database can quickly grow quite large.)</p>"},{"location":"emitpy/Broadcast/Message/","title":"Message","text":"<p>A Message is an entity that is broadcast on a special queue called The Wire. All Messages are sent on The Wire.</p> <p>Message are mainly created for notification of information purpose. Any entity can have Messages associated with it:</p> <ul> <li>Flights</li> <li>Missions</li> <li>Services</li> </ul> <p>Each of the above core entity, its associated movements or emissions, each has its own set of messages. A dependent entity includes the messages of its parent entity. A Movement has its own set of messages and includes those of the parent core entity. A Emit has its own set of messages and includes its parent movement entity. At the end, it is the collection of messages of the Emit that is sent to The Wire after scheduling.</p> <p>The core work of emitpy is to broadcast positions of vehicle (together with meta-data), messages is another set of data that can be broadcast but does not carry a position, only a time of emission, absolute, or relative to the movement it relates to.</p>"},{"location":"emitpy/Broadcast/Message/#messages","title":"Messages","text":"<p>Here is a list of messages that are created and published.</p> <p>For aircrafts and their movements:</p> <ul> <li>ACARS OOOI messages</li> <li>Notification of flight rescheduling or ETA/ETD adjustments</li> </ul> <p>For services and their movements:</p> <ul> <li>Start and end of service.</li> </ul> <p>For Missions and their movements:</p> <ul> <li>Start and end of Missions</li> <li>Arrival at Mission Checkpoint</li> </ul> <p>Additionally, emitpy generates a few internal messages like:</p> <ul> <li>occasional broadcast of each queue current date/time,</li> <li>queue creation and suppression,</li> <li>operational messages related to the simulation.</li> </ul>"},{"location":"emitpy/Broadcast/Message/#message-scheduling","title":"Message Scheduling","text":"<p>Messages are scheduled (and rescheduled) to remain synchronized with their corresponding source (often a movement).</p> <p>When re-scheduled, a ReMessage loads an existing message (from the file or Redis database) and its absolute emission time is re-calculated. It is saved with its new schedule, and enqueued for broadcast with its new emission time.</p> <p>See also ReEmit.</p>"},{"location":"emitpy/Broadcast/Message/#message-text","title":"Message Text","text":"<p>Messages have:</p> <ul> <li>a mandatory Subject</li> <li>an optional Body</li> <li>an optional link</li> <li>meta-data, including status and priority.</li> </ul>"},{"location":"emitpy/Broadcast/Message/#message-categories","title":"Message Categories","text":"<p>Messages have a type:</p> <ul> <li>normal (as produced by emitpy entities to communicate their evolution)</li> <li>operational (about the behavior of emitpy)</li> <li>internal (about the internal behavior of emitpy)</li> </ul> <p>Inside each type of message, messages belong a a category to determine its use. For example, normal messages can below to - ACARS OOOI message, - flight board message to display flight status evolution, scheduling, delays\u2026, - service messages to communicate a service has started or ended, - \u2026</p>"},{"location":"emitpy/Broadcast/Message/#message-decorations","title":"Message Decorations","text":"<p>Messages contain a few decorative attributes to help presentation.</p> <ul> <li>Icon</li> <li>Color</li> </ul>"},{"location":"emitpy/Data/Aircraft/","title":"Aircraft Type","text":"<p>An aircraft type is a ICAO Aircraft Type Designator. Aircraft Type also has:</p> <ul> <li>Manufacturer</li> <li>Model name</li> <li>Aircraft type (for airliners, aircraft class)</li> </ul> <p>Aircraft Type optionally has:</p> <ul> <li>Number of engines</li> <li>Type of engine</li> <li>Wingspan</li> <li>Length</li> <li>Landing gear width</li> <li>A list of either alternate, or closely similar aircraft type designators</li> <li>A list of equivalent IATA aircraft type designators</li> </ul>"},{"location":"emitpy/Data/Aircraft/#aircraft-type-equivalence","title":"Aircraft Type Equivalence","text":"<p>There is a special file <code>aircraft-equivalence</code> that list ICAO and IATA code close equivalence.</p> <pre><code>A321:\n    - \"321\"\n    - \"32S\"\n    - \"A21N\"\n</code></pre>"},{"location":"emitpy/Data/Aircraft/#aircraft-type_1","title":"Aircraft Type","text":"<pre><code>- Date Completed: 2016-mars-16\n  Manufacturer: Airbus\n  Model: A321neo Sharklet\n  Physical Class (Engine): Jet\n  '# Engines': 2\n  AAC: C\n  ADG: III\n  TDG: 3\n  Approach Speed (Vref): 140\n  Wingtip Configuration: winglets\n  Wingspan- ft: 117.45\n  Length- ft: 146.03\n  Tail Height- ft(@ OEW): 39.70\n  Wheelbase- ft: 55.45\n  Cockpit to Main Gear (CMG): 44.95\n  MGW (Outer to Outer): 29.43\n  MTOW: 206132\n  Max Ramp Max Taxi: 207014\n  Main Gear Config: D\n  ICAO Code: A21N\n  Wake Category: M\n  ATCT Weight Class: Large Jet Eqpt\n  Years Manufactured: tbd\n  Note: tbd\n  Parking Area (WS x Length)- sf: 17 151\n</code></pre>"},{"location":"emitpy/Data/Aircraft/#aircraft-class","title":"Aircraft Class","text":"<p>The Aircraft Class is an aircraft attribute based on aircraft length and/or wingspan. There is a procedure to attempt to automagically determine the class of an aircraft.</p> <p>The Aircraft Class is used as a fall back aircraft model when some data is missing.</p> <p>An Aircraft Class is an Aircraft Type with special keyword class <code>CLASS</code> and a keyword type <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, or <code>F</code>.</p> <p>When the aircraft class cannot be found, aircraft class <code>C</code> is used.</p> <p>For a given class, all data from a typical aircraft of that class is used. There is a class for \u00e9quivalence in Airbus aicraft models, and one for Boeing aircraft models.</p> class Airbus Boeing A A318 B731 B A320 B737-800 C A321neo-LR B787 D A350-900 or A330-800 B777-300 E A340-600 B747-800 F A380-800 -"},{"location":"emitpy/Data/Aircraft/#aircraft-with-performance","title":"Aircraft With Performance","text":"<p>An aircraft with performance is a Aircraft Type augmented with Eurocontrol BADA performance data. Performance data is almost exclusively kinematic.</p> <pre><code>A21N:\n  icao: A21N\n  iata: 32Q\n  takeoff_speed: 145\n  takeoff_distance: 2150\n  takeoff_wtc: M\n  takeoff_recat: Upper Medium\n  takeoff_mtow: 97000\n  initial_climb_speed: 175\n  initial_climb_vspeed: 2000\n  climbFL150_speed: 290\n  climbFL150_vspeed: 1500\n  climbFL240_speed: 290\n  climbFL240_vspeed: 1200\n  climbmach_mach: 0.78\n  climbmach_vspeed: 1000\n  cruise_speed: 450\n  cruise_mach: 0.78\n  max_ceiling: 390\n  cruise_range: 4000\n  descentFL240_mach: 0.78\n  descentFL240_vspeed: 1500\n  descentFL100_speed: 290\n  descentFL100_vspeed: 2500\n  approach_speed: 250\n  approach_vspeed: 1300\n  final_speed: 210\n  landing_speed: 140\n  landing_distance: 1850\n  landing_apc: C\n  wingspan: 35.8\n  length: 44.51\n  height: 11.76\n</code></pre>"},{"location":"emitpy/Data/Aircraft/#aircraft","title":"Aircraft","text":"<p>An Aircraft is an airframe with a registration number and an ICAO 24bit hexadecimal ADS-B emitter address. It may also contain its serial number if available.</p>"},{"location":"emitpy/Data/Aircraft/#aircraft-ground-support-equipment-profile","title":"Aircraft Ground Support Equipment Profile","text":"<p>The Aircraft Ground Support Equipment Profile is a set of 3D oriented positions relative to the tip nose of the aircraft. These positions are used to place ground support equipment vehicle around the aircraft frame. There is such a file for each AircraftType. If a profile cannot be found for a precise aircraft type, a profile is searched for similar types. If no profile can be found, the class profile is used. If no class profile can be found, the default, standard, always available class <code>C</code> is used.</p> <pre><code>ac-type: A320\nservices:\n    sewage:\n      - 35\n      - 0\n      - 90\n    cleaning:\n      - 30\n      - 25\n      - 0\n    catering:\n      - 32\n      - 5\n      - -90\n    fuel:\n      - 15\n      - 10\n      - 90\n    fuel2:\n      - 15\n      - -10\n      - -90\n    water:\n      - 35\n      - 4\n      - 90\n</code></pre> <pre><code>service-type:\n\t- distance-from-nose-along-aircraft: 13.5 # meters\n\t- distance-from-longitudinal-axis: 4.7. # meter\n\t- orientation-of-vehicle-relative-to-aircraft # degrees\n\t- optional-height-for-contact: 6.4 # meters AGL\n</code></pre>"},{"location":"emitpy/Data/Airspace/","title":"Airspace","text":"<p>Airspace data is collected from X-Plane flight simulation game data. Please refer to X-Plane documentation for file format.</p>"},{"location":"emitpy/Directory/Company/","title":"Company","text":"<p>A Company is a named entity that represent an actor in emitpy. Examples of companies are:</p> <ul> <li>Airlines</li> <li>Service handlers</li> <li>Airport services such as Police, Customs, or Firefighting Department.</li> </ul>"},{"location":"emitpy/Directory/Directory/","title":"Directory","text":"<p>The directory is a database of all operating companies at the airport.</p>"},{"location":"emitpy/Directory/Identity/","title":"Identity","text":"<p>An Identity is the base class for named entity in the Emitpy application. It contains the following mandatory attributes:</p> <ul> <li>A Organisation Identifier <code>orgId</code></li> <li>A Class identifier <code>classId</code></li> <li>A Type identifier <code>typeId</code></li> <li>A name <code>name</code></li> </ul> <p>The four attributes were inspired years ago by a IBM IoT naming scheme and allow for fine flexible naming and classification. The original identifiers were orgId, classId, deviceType, deviceId.</p> <p>All objects or entities in Opera have an identifier.</p> <p>The owning organisation, orgId is used to designate the entity responsible for the management of the object or entity.</p> <p>The classId is used to organise entities and objects in broad categories.</p> <p>The typeId is used to distinguish different entities in the same class.</p> <p>Finally, the entity name designated a very precise entity. It can be a serial number, a registration number, or a user assigned unique identifier.</p> <p>In general, the four identifier parts are grouped together in a <code>:</code> separated string.</p>"},{"location":"emitpy/Directory/Identity/#examples-of-identifiers","title":"Examples of Identifiers","text":"<p>Brussels Airline:Aircraft:A35K:OO-PMA</p> <p>OTHH:Airway:Taxiway:W05</p> <p>Airbus:Airliner:A32N:Airbus A320 Neo</p> <p>OTHH:Airport::Hamad International Airport (please note no <code>typeId</code>.)</p> <p>QAS:GSE:fuel-hydrant:FU04</p>"},{"location":"emitpy/Directory/Identity/#notes-about-identifier","title":"Notes about Identifier","text":"<p>The idea about the above proposed scheme is that:</p> <p>The first part, the Organisation Identifier determine the entity responsible for the device. It assumes the organisation will also take responsibility of naming devices with the remaining 3 fields.</p> <p>The Class of Device assumes a broad category of device classification, probably a functional typing of the device.</p> <p>The Type of the Device allows for different devices in this functional class: different devices, or models.</p> <p>Finally, the Device Identifier can simply be a serial number, a registration, or any other identifier that uniquely point at this device.</p> <p>In our context, here are a few examples of each identity part.</p> <ul> <li>Organisation: Airport, Handler, airport services, aircraft manufacturer</li> <li>Class: Vehicle type like aircraft, GSE, etc.</li> <li>Type: Aircraft ICAO type, GSE vehicle type (like tow-bar-A32X)</li> <li>Name: Aircraft or vehicle registration or serial number</li> </ul>"},{"location":"emitpy/Directory/Identity/#technical-note","title":"Technical Note","text":"<p>Often, all four identifier are concatenated into a single, <code>:</code> separated list.</p> <p><code>Airport:Ground Handling:Catering:CAT002</code></p> <p>Note</p> <p>Try to avoid using <code>:</code> in organisation, class, type and device identifier fields.</p> <p>You are welcomed to use another separator (let us say <code>|</code>) inside the above fields.</p> <p>For example</p> <p><code>HamadIntl|QAS:GSE|Fuel:Hydrant:FU007</code></p>"},{"location":"emitpy/Flight/Aerospace/","title":"Aerospace","text":"<p>The Aerospace entity is a container entity for everything related to aerospace where aicrafts can fly. It contains:</p> <ul> <li>Terminals (airports),</li> <li>Navigational aids,</li> <li>Fixes, waypoints,</li> <li>Airways, optionally with their restrictions,</li> <li>Holds,</li> <li>Airspaces, optionally with their restrictions.</li> </ul> <p>Note</p> <p>Note: The container class name Aerospace has been used since release 0.12 to distinguish from Airspaces which have a precise and well defined meaning in aeronautics.</p>"},{"location":"emitpy/Flight/Aerospace/#aerospace","title":"Aerospace","text":"<p>The Aerospace is an abstract base class to define Aerospace for emitpy. An aerospace must contain the following data</p> <ul> <li>Navigational aids,</li> <li>Fixes and waypoints,</li> <li>Airway segments between navaids and/or fixes.</li> </ul> <p>but this data can be aquired from different sources.</p> <p>An Aerospace is a (network) graph, with navaids and fixes being vertices and airways being edges.</p> <p>The aerospace graph is used to find routes between airports using airways. (Ultimately, if no route can be found between two airports, a direct grand circle arc can be used between departure and arrival airports.)</p>"},{"location":"emitpy/Flight/Aircraft/","title":"Aircraft","text":"<p>An Aircraft is entity that reprensent a precise frame. An aircraft has</p> <ul> <li>A registration</li> <li>An optional initial registration or serial number</li> <li>An ICAO24 bit address, often presented as a 6 hexadecimal character suite,</li> <li>but most importantly, has an Aircraft Type (with performance data associated to it).</li> </ul> <p>It can also contain other properties like its seating or cargo configuration.</p>"},{"location":"emitpy/Flight/Aircraft/#aircraft-type","title":"Aircraft Type","text":"<p>The Aircraft Type is a named entity. Common aircraft types in ICAO DOC8643 are loaded, together with their IATA code if available.</p> <p>There is a Aircraft Type equivalence, to link similar aircrafts together, either through their IATA code or their ICAO code.</p>"},{"location":"emitpy/Flight/Aircraft/#aircraft-type-with-performances","title":"Aircraft Type with Performances","text":"<p>Common aircraft types used for civil aviation are loaded together with their performances as extracted from Eurocontrol Aircraft Performance Database (BADA).</p>"},{"location":"emitpy/Flight/Aircraft/#aircraft-class","title":"Aircraft Class","text":"<p>Each Aircraft Type with Performance is assigned a class (Letters A (small) to F (A380)) based on their wingspan and length. An Aircraft Class is a Aircraft Type with Performance for a group of similar aircrafts representing similar physical characteristics and performances. When characteristics for an aircraft are not found in its Aircraft Type with Performance, data is looked up in its Aircraft Class.</p> <pre><code># ws = wing span in meters\n    try_class = \"A\"\n    if ws &gt; 78:\n        try_class = \"F\"\n    elif ws &gt; 65:\n        try_class = \"E\"\n    elif ws &gt; 50:\n        try_class = \"D\"\n    elif ws &gt; 40:\n        try_class = \"C\"\n    elif ws &gt; 32:\n        try_class = \"B\"\n</code></pre>"},{"location":"emitpy/Flight/Aircraft/#aircraft-ground-support-equipment-profile","title":"Aircraft Ground Support Equipment Profile","text":"<p>An Aircraft Ground Support Equipment profile list all GSE and where they should be positioned relative to the aircraft's nose tip (= (0, 0), left, relative to aircraft direction is x negative values, right is positive values, in front of aircraft y is negative value, on the aircraft side it is positive value.</p> <p>The profile depends on the model of the aircraft. If the profile is not available for the model of the aircraft, there is a fall-back on the class (A-F) of the aircraft. If a class of aircrafts is not found, there is fallback on class C which is always available and defined. (Class C is the largest narrow body aircraft type.)</p>"},{"location":"emitpy/Flight/Aircraft/#aircraft-turnaround-profile","title":"Aircraft Turnaround Profile","text":"<p>An Aircraft Turnaround Profile list all tasks that occurs during a turnaround.</p> <p>The profile depends on 1. the direction of the flight: arrival or departure 2. the type of flight: cargo or passenger 3. the type of the ramp: jetway or remote parking (called tie down) 4. the model of the aircraft, or it\u2019s class, 5. the airline or ground handling company operating the flight or the turnaround</p> <p>If one of the above depending data is not available, there always is a fall back solution ultimately selecting a class C aircraft being serviced for cargo or passenger at a gate or tide-down remote parking.</p>"},{"location":"emitpy/Flight/Flight%20Route/","title":"Flight Route","text":"<p>A Flight Route is a flight path from an origin airport to a destination airport only flying on airway segments.</p>"},{"location":"emitpy/Flight/Flight%20Route/#notes-on-route-and-flight-plan-building","title":"Notes on Route and Flight Plan Building","text":"<p>High and Low airways are not distinguished, they are all airways. (May be refined later, algorithm needed.)</p> <p>QFU is determined on both departure and arrival airport if possible solely based on wind direction at the location, at the time of the flight if possible, using (historical) METAR and/or TAF. If several runways meet wind orientation restrictions, one is randomly selected. If no wind direction is available at an airport, all runways can be used for take-off or landing.</p> <p>There is no \"local policy\" enforcement, i.e. 25R for taking-off and 25L for landing.</p> <p>When a runway has been selected, flight procedures are selected. Procedures that makes the shortest flight in distance are selected.</p> <p>The above selection process makes a flight fairly random. Supplying the same parameters can lead to several flight plans and paths for the same departure and arrival airport. A pair of multi-runway large airports with no wind (i.e. random runway) can lead to up to a few dozen of different flight plans and paths for the same departing and arrival airports.</p> <p>To circumvent this randomness, in case of need, to reproduce the exact same flight, it is optionally possible to supply runways and procedures to use at both ends. This leads to a repeating flight path, provided weather is not changed. This allow, for example, to test different aircrafts or variables with different performances for the same flight.</p>"},{"location":"emitpy/Flight/Flight%20Route/#take-off-initial-climb-and-final-fix","title":"Take-Off, Initial Climb and Final Fix","text":"<p>Take-off always occurs in a straight line, ascending at initial-climb speed and vertical speed, up to 1500ft. After that, there is a Direct Fix to the first point of the SID procedure if any.</p> <p>On arrival, the last point of the approach procedure always leads (Direct to Fix) to an artificial final fix point that is always on the slope of a line that starts at 2000ft (ABG) and terminates 300m after the runway threshold, where kiss-landing always occurs. The slope of the line is adjusted for aircraft landing speed and a vertical speed of 600ft / minute.</p> <p>On arrival also, if the last point of the flight plan does not contain an altitude restriction, it is assigned one. The altitude set for the restriction depends on the distance of this last point to the airport. (A speed restriction might also be applied.) Please recall that during descent, altitude restrictions are carried forward to the next point if he next point does not have a restriction.</p>"},{"location":"emitpy/Flight/Flight%20Route/#transitions","title":"Transitions","text":"<p>Transitions are always Direct to Fix. To the next point. This may result in sometimes in unusual turns from last procedure waypoint to next procedure waypoint.</p> <p></p>"},{"location":"emitpy/Flight/Flight%20Route/#about-taxiing","title":"About Taxiing","text":"<p>Taxi occurs on the local network of taxiways.</p> <p>Currently, the following simplification have been taken into account: - No one-way taxiway (they are all two-ways). - Taxiway width not taken into account for aircraft class (width). - Runways are most of the time taxiways. Therefore, the shortest path to a destination may result in a U-turn on the runway. - Speed on taxiways is uniform.</p>"},{"location":"emitpy/Flight/Flight/","title":"Flight","text":"<p>A Flight is a container entity that represent the movement of an aircraft between two airports, one of them being the Managed Airport. There are two types of Flight: - Arrival flights are flights that arrive at the Managed Airport, - Departure flights are flights that leave the Managed Airport.</p> <p>The creation of a flight is a 3 step process:</p> <ul> <li>Creation of the Flight Plan</li> <li>Creation of the Flight Movement, including airport procedures and taxi at the managed airport</li> <li>Smoothing of the Flight Movement to make the journey more realistic.</li> </ul>"},{"location":"emitpy/Flight/Flight/#flight-plan","title":"Flight Plan","text":"<p>A Flight Plan is a succession of flight segments.</p> <p>First a Flight Route is created from departure airport to arrival airport. Route is created following high and low airways. An arbitrary flight level is decided based on the distance between the two airports.</p> <p>The flight plan is completed by flight procedures, if available, around both terminal areas. Flight produces are selected according to weather information (QFU from weather METAR and/or TAF), and some randomness. Airport local usage and rules are not enforced, but rather randomly selected.</p> <p>A flight plan only contains lateral navigation and restrictions.</p> <p>Procedures are inserted and respected. Cruise is adjusted between end of SID and start of STAR; cruise points may be removed if they imply in-flight U-turns.</p>"},{"location":"emitpy/Flight/Flight/#flight-movement","title":"Flight Movement","text":""},{"location":"emitpy/Flight/Flight/#movement-complements","title":"Movement Complements","text":"<p>The Flight Movement is a Movement. It is the flight plan completed with:</p> <ol> <li>Vertical navigation with altitude restrictions,</li> <li>Lateral and vertical navigation with speed restrictions,</li> <li>Taxi in or out at the managed airport, from the runway to the parking position for arrival flights, or from the parking position to the start of the runway for departing flights.</li> </ol> <p>Vertical navigation is added taking into account Aircraft Performances for speeds, accelerations, and operating limits. Vertical navigation is geometric, taking into account aircraft capabilities.</p> <p>Airway restrictions are not taken into account. Aircraft either flight high altitude airways, or low altitude airways, or both combined together. (One day aircraft will flight low airways below ~\u00a0FL180 and high airways above.)</p>"},{"location":"emitpy/Flight/Flight/#notes-on-flight-movement","title":"Notes on Flight Movement","text":"<p>The relation between flight plan waypoints and movement points is preserved. However, several movement points may be attached to a single flight plan waypoint.</p> <p>Mots natably, for example:</p> <ul> <li>Take off hold, take-off, and end-of-initial-climb points are all attached to the departing airport.</li> <li>(Artificial) final fix, touch-down, and end-of-roll are all attached to the arrival airport waypoint.</li> <li>When a \"smooth turn\" (fly by or fly over) is added at a fly plan waypoint, all movement points are attached to the flight plan waypoint.</li> </ul>"},{"location":"emitpy/Flight/Flight/#flight-smoothing","title":"Flight Smoothing","text":"<p>At this stage, the flight consists of straight flight segments with no smooth transitions. The smoothing algorithm adds a few limited adjustment to the flight path (fly-by waypoints, smooth procedure turns, straightforward transitions (direct-to), etc.)</p> <p>Finally, data and meta data is carried over from vertices to vertices, linearly interpolating values when necessary.</p> <p>The Fliht Movement is a succession of segments, each vertex has information relative to the aircraft movement (speed, altitude, vertical speed, etc.)</p>"},{"location":"emitpy/Flight/Flight/#summary","title":"Summary","text":""},{"location":"emitpy/Flight/Flight/#flight-times","title":"Flight Times","text":"<p>Flights have three times associated with them:</p> <ul> <li>The Scheduled date/time is mandatory and always used to create the flight.</li> <li>If an Estimated time of arrival/departure is available, the flight can be \"rescheduled\" accordingly.</li> <li>Finally, when a flight is completed, an Actual flight time is recorded.</li> </ul> <p>Scheduled and actual flight times cannot be changed. If the Estimated time is not available, the Scheduled time is used. (Note: Changes of ETA/ETD are kept in a historical structure to keep track of estimated time adjustments and refinements.)</p>"},{"location":"emitpy/Flight/Flight/#flight-identifier","title":"Flight Identifier","text":"<p>IATA has a well-defined method to identify a commercial flight. We adjusted the method to suit our needs. A flight is identified by</p> <ul> <li>The operator of the flight</li> <li>The flight number</li> <li>The date/time of the departure of the flight from the origin airport in Universal Time.</li> </ul> <p>The date/time used in the identifier of an arrival flight is the approximated scheduled date/time of departure of the flight from the last airport (where the flight landing at the Managed Airport is coming from, i.e. the last leg only. Example: If the flight is BOS-&gt;LHR-&gt;DOH, we use the departure time of the last leg, i.e. departure from LHR, not the departure from BOS as IATA would.) The date/time used in the identifier of a departing flight always is the scheduled departure time from the managed airport.</p> <p>Once the Flight Movement is created, an aircraft can broadcast its position.</p>"},{"location":"emitpy/Flight/Procedure/","title":"Procedure","text":"<p>Coded Instrument Flight\u00a0Procedures are read from FAA data files and exposed as flight segments usable by Emitpy.</p> <p>The following entities are created:</p> <ul> <li>Terminal (an airport)</li> <li>RWY (a runway, if available, two opposite runways are paired, like 34L and 16R)</li> <li>SID</li> <li>STAR</li> <li>APPCH</li> </ul> <p>Also, available in the Airspace structure are - Fixes - Holding positions and patterns</p> <p>For an airport involved in a flight, those procedures are loaded \"on demand\" (Airport#AirportWithProcedures). (I.e. all procedures are not loaded for all airports.)</p>"},{"location":"emitpy/Flight/Procedure/#turns","title":"Turns","text":"<p>During the flight route smoothing, turns are modified to provide a realistic flight path. At each vertex, the flight proceeds with either a fly-by or a fly-over path, as requested by waypoints.</p>"},{"location":"emitpy/Flight/Procedure/#fly-by","title":"Fly-By","text":"<p>For fly-by waypoints, a smooth standard turn is built in front of the waypoint. For very sharp angle turns, this can lead to very early turns. A center of turn path is found between the two segments and then a turn is added, tangent to both segments.</p> <p></p>"},{"location":"emitpy/Flight/Procedure/#fly-over","title":"Fly-Over","text":"<p>Flight over waypoint proceed with two coordinated standard turns. After flying over the way point, the aircraft turns in the direction of the next way point. The turn angle is set to 150% of the original turn angle toward the next way point (but no more than a 180\u00b0 U-turn) to allow the aircraft to fly back on next leg. From the new temporary heading, the aircraft proceed with a smooth fly-by at the intercept point to continue its journey towards the next waypoint. This is done only if the aircraft has time to join the next leg smoothly before the reaching the next waypoint.</p> <p></p> <p>When waypoints are too close, some turns may not be performed fully. The fallback is a fly-by towards the next way point, which may, sometimes, lead the aircraft temporary out of its allowed airspace. In extreme circumstances, when waypoints are too close, some waypoint may be omitted or suppressed from the flight path.</p> <p>Radius is computed at turn entry speed to complete a standard turn (360\u00b0 in 2 minutes). Radius remains contant for the duration of the turn, even if aircraft speed changes during the turn. Aircraft will accelerate/decelerate at turn exit to comply with the next leg requirements.</p> <p>When turn angle is too shallow, turn smoothing my be omitted.</p>"},{"location":"emitpy/Flight/Restrictions/","title":"Restrictions","text":"<p>About airspace restrictions and their partial handling.</p> <p>Emitpy is not a professional tool, but rather an accessory simulator that is used to generate realistic but imperfect flight paths. It has therefore the following limitations.</p>"},{"location":"emitpy/Flight/Restrictions/#notes-about-restriction-handling","title":"Notes about Restriction Handling","text":"<p>To simplify restriction handling, Emitpy uses a naive algorithm that works as follow:</p>"},{"location":"emitpy/Flight/Restrictions/#restrictions-when-climbing","title":"Restrictions when Climbing","text":"<p>When climbing, we clear above altitude restrictions one after the other. The rationale being that it is harder to climb to clear above altitude restrictions. When climbing towards the next above altitude restriction, we remain under below altitude restrictions that may occur while reaching the next above altitude restriction, and reduce climb rate to respect those restrictions.</p> <p>As now, change of vertical movement is solely done exactly at waypoints, not \u00ab\u00a0between\u00a0\u00bb waypoints. To optimise flight plans and movement, it would be advisable to revise this limitation and start climbs or descend at more appropriate times, taking into account finer aircraft performances and other preoccupations like fuel usage and environmental constraints. This process it complex and out of the scope of this simulator.</p>"},{"location":"emitpy/Flight/Restrictions/#restrictions-when-descending","title":"Restrictions when Descending","text":"<p>When descending, we clear below altitude restrictions one after the other. When descending towards the next below altitude restriction, we remain above above altitude restrictions and reduce descend rate to respect those restrictions. This sometimes requires expediting following descends to meet following restrictions.</p>"},{"location":"emitpy/Flight/Restrictions/#top-of-descend","title":"Top of Descend","text":"<p>The Top of Descend is searched backwards from the first below altitude restriction. The length of the first descend from cruise altitude is limited to ~100km (54Nm).</p> <p>The static value is compared to the rule of thumb value</p> <pre><code>(3 x height) + (1nm per 10kts of speed loss) + (1nm per 10kts of Tailwind Component)\nNotes:\n10kts = 5.144444 m/s\nTailwind: add 10nm for safety\n</code></pre> <p>Both values are always very close for typical airliners descending to typical STAR.</p> <p>If, for a short flight, the climb was not finished at the top of descend, a warning is issued and the flight level of the whole flight is adjusted accordingly. This should not happen if flight level was computed by Emitpy because Emitpy has a procedure to compute the optimum flight level for a given distance.</p>"},{"location":"emitpy/Flight/Restrictions/#airway-restrictions","title":"Airway Restrictions","text":"<p>There is currently no airway restriction implemented, although all hooks to do it are ready. (One day, may be.)</p> <p>The only constraint that are handled during flight plan calculation are airway types (high, low, or both) and direction (one way, two way). These restrictions are sometimes relaxed if no route can be found between two airports. In this cas, a warning is issued together with the restriction that is abandoned.</p> <p>While left as a parameter, transition from low to high airways is always performed at FL180.</p>"},{"location":"emitpy/Flight/Restrictions/#speed-restriction","title":"Speed Restriction","text":"<p>Speed restriction is enforced last on the whole flight, one restriction at a time, taking into account flight phases (takeoff, climb, acceleration, cruise\u2026) THERE IS NO ADJUSTMENT of climb rates, distances, etc. if speed was modified because of a restriction.  We understand this is a limitation, acceptable under most circumstances, the main reason being that resprictions have, themselves, been implemented taking into account aircraft performances (PBN).</p> <p>While left as a parameter, restriction to maximum 250kn is enforced at FL100, unless a local constraint impose otherwise.</p>"},{"location":"emitpy/Flight/Restrictions/#notes-about-vertical-navigation","title":"Notes about Vertical Navigation","text":"<p>To easy vertical navigation, the following is imposed to all flight movements.</p> <p></p> <p>On take-off, the aircraft climbs in a straight line, aligned with the runway, at its nominal initial climb speed and vertical speed up to an altitude of 1500ft (450m) ABG, which is tipically reached after 3 to 5km. There is then a direct-to-fix vector to the first point of the SID, if any, or to the first point of the journey. The last point of initial climb is marked as such. If there is no SID procedure, the aircraft climbs at its nominal speed and climb rate until it reaches the planned flight level.</p> <p>On landing, there is an artificial final fix point placed at 2000ft from the touch down point and the aircraft uses a 600ft/min vertical speed. During that time, it flies at its landing speed. On final approach, there is a direct vector from the last point of the approach procedure to this artificial final fix point. If the approach procedure terminates below 2000ft, the artificial fix point is moved towards the touch down point to intercept the last procedure altitude. If no STAR and/or approach procedure is used, the artificial final fix behaves like the last at or below altitude restriction.</p> <p>There is no environmental contraint. (CO2 reduction, fuel economy, noise abatment, etc. sorry.)</p>"},{"location":"emitpy/Flight/Weather/","title":"Weather","text":"<p>Emitpy takes into account weather information at the following flight phases:</p> <ul> <li>Departure airport: Wind speed and direction, precipitations; to select runway orientation and adjust take-off distance.</li> <li>En route: Wind at the expected aircraft level; to adjust ground speed and heading.</li> <li>Arrival airport: Wind speed and direction, precipitations; to select runway orientation and adjust landing distance.</li> </ul> <p>Weather can be provided from different sources.</p>"},{"location":"emitpy/Flight/Weather/#weather","title":"Weather","text":""},{"location":"emitpy/Flight/Weather/#weather-at-airports","title":"Weather at Airports","text":"<p>The API for weather at airport is limited to:</p> <ol> <li>Wind speed and direction</li> <li>Amount of precipitations</li> </ol> <p>Weather can be requested at any time (default is now).</p> <p>For current and historical weather at airport, Emitpy uses METAR reports. For weather at airport in a close future (less than 24 hours), Emitpy uses TAF reports.</p> <p>METAR and TAF reports are fetched from NOAA servers.</p> <p>If a past weather cannot be fetched, the current weather is be used instead, or weather information can be ignored.</p> <p>Past METAR are fetched from ogimet archive server, however access is limited.</p> <p>If weather cannot be determined at an airport, runway orientation (QFU) is randomly selected, and VFR conditions are assumed with no precipitation.</p> <p>METAR and TAF are cached and never fetched twice.</p>"},{"location":"emitpy/Flight/Weather/#en-route-weather","title":"En Route Weather","text":"<p>The API for en-route weather limited to: 1. Wind speed and direction at given 4D position (latitude, longitude, altitude, time) Wind can be requested at any time (default is now).</p> <p>For current en-route weather, Emitpy uses</p> <ul> <li>either current GFS prediction for the next flight hours/duration (typically 12, 18, or 24 hours),</li> <li>or X-Plane pre-processed weather files (also in GRIB format, predictions at 3 and 6 hours, updated frequently if X-Plane is running.</li> </ul> <p>GFS files are fetched from GFS servers available worldwide.</p> <p>For past en-route weather, Emitpy uses past GFS files if available. If not available emitpy either uses the current GFS file if available or ignore wind during cruise phase.</p> <p>If en-route weather cannot be fetched, no wind is added to the flight (course=heading, speed=TAS).</p> <p>Other forecast algorithms can be used for en-route wind estimation. GFS are widely available.</p>"},{"location":"emitpy/Flight/Weather/#flight-time","title":"Flight Time","text":"<p>Depending on the flight time, past or present, it is possible to fetch weather at the following moment.</p> <p>Emitpy allows to replay a flight that was scheduled in the past at any time. For example, a flight that was originally scheduled Apr. 1rst 2019 at 10am can be played Aug. 6 2023 at 11. Since the flight occurs on Aug. 6<sup>th</sup> the weather at that time is be fetched.</p>"},{"location":"emitpy/Flight/Weather/#arrivals","title":"Arrivals","text":""},{"location":"emitpy/Flight/Weather/#airports","title":"Airports","text":"<p>For Arrivals, weather at departure and arrival airports can be determined from historical or current METAR. If historical METAR is not available, the current METAR is used instead.</p>"},{"location":"emitpy/Flight/Weather/#en-route","title":"En-Route","text":"<p>For en-route winds, we use the wind predictions that were available at the time of departure, like pilots would have taken into account in their flight plan. The fall back is to use the current forecast.</p>"},{"location":"emitpy/Flight/Weather/#departure","title":"Departure","text":""},{"location":"emitpy/Flight/Weather/#airports_1","title":"Airports","text":"<p>For departing airport, we use historical or current METAR. For arrival airport, for a flight in the past, we use (in order):</p> <ul> <li>Historical METAR at the time of arrival (exact weather)</li> <li>Historical TAF at the time of departure, like pilots would have used</li> <li>Current TAF at destination at time of departure</li> <li>Current METAR at destination at time of departure</li> </ul> <p>For a flight \u00ab\u00a0now\u00a0\u00bb, we use the current TAF at the destination airport. (Since we mainly deal with large airports, TAF are often available.) If the TAF is not available at the destination airport, we use the current METAR.</p>"},{"location":"emitpy/Flight/Weather/#en-route_1","title":"En-Route","text":"<p>For en-route winds, we use the historical wind predictions that were available at the time of departure for the departure airport, like pilots would have taken into account in their flight planning. The fall back is to use the current forecast.</p>"},{"location":"emitpy/Flight/Weather/#forecast","title":"Forecast","text":"<p>For en-route wind forecast, we only use one set of data for simplicity. The time of the prediction is not adjusted as flight progresses. Depending on the duration of the flight, we try to get the following prediction:</p> <ul> <li>Flights less that 6 hours: predictions at 3 h (after the scheduled or estimated time of departure)</li> <li>Flights more that 6 hours: predictions at 6 hours.</li> </ul> <p>Both forecast at readily available, especially when using X-Plane Real weather files.</p> <p>Same occurs when trying to estimate TAF predictions to be taken into account at the scheduled or estimated time of arrival at destination airport.</p>"},{"location":"emitpy/Flight/Weather/#weather-engine","title":"Weather Engine","text":"<p>The Weather Engine is responsible for providing weather information at airports (historical or current METAR or TAF), and for flight routes.</p>"},{"location":"emitpy/Flight/Weather/#weather-adjustment","title":"Weather Adjustment","text":"<p>There is no adjustment (changes of flight level, heading, etc.) to optimise flights when weather is added. The weather (wind) component is simply added to the flight route, only altering speed and timing information.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/","title":"(Airport) Points of Interest","text":"<p>To enhance movement realism, emitpy needs a few named points of interest as destination. It is not possible to find those points in any database. We recommand using a tool like geojson.io to create a GeoJSON FeatureCollection with all named point. Point must be attached a few GeoJSON Feature properties to identify and qualify them.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#service-roads","title":"Service Roads","text":""},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#service-depot","title":"Service Depot","text":"<p>For a give service, a depot is the location from which all service vehicle will start. There may be more than one depot for a given service. A depot may be used by one type of service only.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#properties","title":"Properties","text":"<p>type: depot service: list of <code>|</code>-separated service names. name: optional depot name, if not provided, a default name will be generated.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#service-rest-area","title":"Service Rest Area","text":"<p>A Rest Area is a point where service vehicle go when they do not provide a service. Alternatively, they may also go to a depot. There may more than one rest area for a given service. A given rest area may be used for different services.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#properties_1","title":"Properties","text":"<p>type: rest-area service: list of <code>|</code>-separated service names or  <code>*</code> for all services. name: optional rest area name, if not provided, a default name will be generated.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#mission-checkpoint","title":"Mission Checkpoint","text":"<p>A Checkpoint is a named point of interest on the service road network. There currently is only one type of check point. It is possible to name them in such a way that they exhibit some category. For example: security:gate:west-5, or cargo:custom:landside-4.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#properties_2","title":"Properties","text":"<p>type: checkpoint service: mission name: optional checkpoint name, if not provided, a default name will be generated.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#aeroways","title":"Aeroways","text":""},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#runway-exit","title":"Runway Exit","text":"<p>Runway exits are difficult to identify (need network analysis). For smiplification, it is advisable to provide a list of runway exits on either side of the runway. When an aircraft ends its landing roll and reaches a speed of about 50km/h (~\u00a030kn) or less, it may exit the runway towards the network of taxiways. Runway exit points are named after the runway: <code>RW34L:exit:5L</code> is the same as <code>RW16R:exit:3R</code>.</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#properties_3","title":"Properties","text":"<p>type: runway-exit runway: Runway name format <code>RWnn{LCR}</code> name: optional runway exit name, if not provided, a default name will be generated. side: left or right, relative to aircraft direction (optional)</p> <p>Emitpy tries to locate runway exists by finding taxiway nodes close or on the runway. However, this procedure sometimes fails, resulting in a runway with no exit point. In this case the only exit is at the runway end. (Opposite take-off hold position.)</p>"},{"location":"emitpy/Geolocalized%20Entities/%28Airport%29%20Points%20of%20Interest/#take-off-queue-point","title":"Take-Off Queue Point","text":"<p>A Take-Off Queue point is a fixed position where an aircraft stops when queueing for take-off. Take-Off Queue Points are built as regularly spaced points on a line string. For each runway, it is necessary to supply a linestring that starts at a the runway take-off hold position, and that runs backward towards the terminal areas. Emitpy will create queueing positions from the take-off hold position (queueing position 0), at regular intervals (parameter QUEUE_GAP \u2243 200 meters), until the end of the supplied line string. If the supplied line string is shorter than the QUEUE_GAP, only one queueing position is created (0) at the the take-off holding position. If no linestring is supplied, emitpy will try to run backward on taxiways from the take-off hold position, to create at least 1 queueing position. However, this position may end up in a unwanted place on the taxiway network (that is runway included if runways can be used for taxiing).</p> <p>In all cases, at least one queueing position is created (0) at the the take-off holding position, which the destination of aircraft taxiing for take-off.</p> <p>Please note that aircrafts always take off from the beginning of the runway.</p>"},{"location":"emitpy/Geolocalized%20Entities/Feature%20Point/","title":"Feature Point","text":"<p>Emitpy uses GeoJSON format for representation, use, input and output of geographic entities. GeoJSON Features in particular carry both geographic information and properties associated with it in a human readable format. (geoyaml would be ideal to get rid of too many quotes.) Python package GeoJSON is used in numerous libraries. However it is feature limited and exhibit some problem (e.g. 162, 178) that prevent its use in emitpy.</p> <p>To circumvent this, emitpy uses a <code>FeatureWithProps</code> subclass of the above GeoJSON Feature that offert necessary GeoJSON features for external libraries, while maintaing a high level of usability for the emitpy development. FeatureWithProps is the base entity for all emitpy geolocalised features.</p> <p>Properties attached by emitpy to FeatureWithProps are stored in a dictionary. Property names are listed in the FEATPROP enumeration. Convenient setter and getter functions are provided for properties. Property values can be dictionaries, leading to a structured list of properties. Ultimately, this hierarchy of properties can be flattened to a simpler list of (name, scalar value) pair.</p>"},{"location":"emitpy/Geolocalized%20Entities/Feature%20Point/#feature-colors","title":"Feature Colors","text":"<p>A Feature is fitted with two special colors a that can be later used to highlight them on a map. Colors can also be used through lookup tables to map other attributes (icons, for example: red=fire-truck icon).</p>"},{"location":"emitpy/Geolocalized%20Entities/Feature%20Point/#subject-color","title":"Subject Color","text":"<p>The <code>subject-color</code> is linked to the emitting vehicle. It can be linked to the type of vehicle (aircraft, fuel, pushback truck, emergency\u2026), its function and model (ambulance, police, fire\u2026)</p>"},{"location":"emitpy/Geolocalized%20Entities/Feature%20Point/#movement-color","title":"Movement Color","text":"<p>The <code>move-color</code> is related to the part of the movement of the emitting vehicle. For an aircraft, it can be linked to the flight phase for example (take-off, climb, cruise, decend\u2026).</p>"},{"location":"emitpy/Geolocalized%20Entities/Location/","title":"Location","text":"<p>A location is a named, geolocalized entity.</p> <p>The location has - A name - The name of a close by city or municipality - A country</p> <p>The geo-location contains - A latitude, longitude coordinate - An optional altitude</p>"},{"location":"emitpy/Geolocalized%20Entities/Movement/","title":"Movement","text":"<p>A Movement is an abstract container for the displacement of a vehicle</p> <ul> <li>either an aircraft through a flight,</li> <li>or a ground support equipment providing a service.</li> </ul> <p>It is a list of successive positions with movement-related information at each position (speeds, etc.) Positions are location where the movement changes, like turns, or change of speed, or sometimes a particular event of the movement like \u00abtouch-down\u00bb.</p> <p></p>"},{"location":"emitpy/Geolocalized%20Entities/Movement/#movement-building","title":"Movement Building","text":"<p>During the construction of the movement, performances of the vehicle is taken into account to determine speed at vertices. In all cases, to simplify, linear acceleration and deceleration is used. (I.e. there is no \"force\" computed from vehicle trust and varying vehicle mass (since it burns fuel), etc. just simple realistic kinematics.) Movement is created using Syst\u00e8me International of unit. However, some values may be displayed in more commonly used imperial or aeronautical units like flight level.</p>"},{"location":"emitpy/Geolocalized%20Entities/Movement/#movement-mark","title":"Movement Mark","text":"<p>Movement contain a list of remarkable points called Marks. A Mark in a movement is a named point in time of the movement. For example, for a flight, there is a Mark for each flight phase: Off-Block, take-off hold, take-off, top of climb\u2026 The most important data for a Mark is its time relative to the start of the movement. (Each mark name should be unique for the movement, otherwise only the first one encountered is kept.)</p>"},{"location":"emitpy/Geolocalized%20Entities/Movement/#movement-time","title":"Movement Time","text":"<p>The movement always start at relative time zero. All times of a movement is relative to its start. Each Mark in the movement will have a time of occurrence relative to the start of the movement.</p> <p>When a Movement is created, its positions can be broadcast.</p>"},{"location":"emitpy/Resource/Equipment/","title":"Equipment","text":"<p>An Equipment is a hardware resource that is used by service, typically Ground Support Vehicle. The vehicle reports it\u2019s position so that it can be integrated into Opera analysis.</p> <p>(will be detailed later, to do)</p>"},{"location":"emitpy/Resource/Equipment/#goods-and-services","title":"Goods and Services","text":"<p>An equipment has a capacity expressed by 4 values that can be adjusted to provide realistic service times.</p>"},{"location":"emitpy/Resource/Equipment/#parameters","title":"Parameters","text":""},{"location":"emitpy/Resource/Equipment/#maximum-capacity","title":"Maximum Capacity","text":"<p>The maximum capacity of a vehicle. Example: Fuel truck 30kLiters, baggage train: 100 cases.</p>"},{"location":"emitpy/Resource/Equipment/#flow","title":"Flow","text":"<p>The time it takes to process one unit of good. Expressed un UNIT per SECOND Example: Fuel flow: 0.6L per second, baggage: 1 baggage every 5 second.</p>"},{"location":"emitpy/Resource/Equipment/#setup-and-cleanup-times","title":"Setup and Cleanup Times","text":"<p>Time to prepare the service, or to clean it up when completed.</p>"},{"location":"emitpy/Resource/Equipment/#working-variables","title":"Working Variables","text":""},{"location":"emitpy/Resource/Equipment/#current-load","title":"Current Load","text":"<p>How much unit of good in the vehicle. Example: Fuel: Truck has 23455L left. Example Baggage: Train has already 60 cases.</p>"},{"location":"emitpy/Resource/Equipment/#requested-service-variables","title":"Requested Service Variables","text":""},{"location":"emitpy/Resource/Equipment/#quantity","title":"Quantity","text":"<p>The quantity of good to deliver or capture. Example: Fuel: 20000L, Baggage: 250 cases, cargo: 30 ULD.</p>"},{"location":"emitpy/Resource/Equipment/#deduced-variables","title":"Deduced Variables","text":""},{"location":"emitpy/Resource/Equipment/#time-to-service","title":"Time to service","text":"<p>time to setup + quantity / flow + time to cleanup. + time to round trip to a depot (and refill/unload) if service cannot be completed in one \u00ab\u00a0trip\u00a0\u00bb. The service can also be a fixed time. Like GPU setup: 3 minutes.</p>"},{"location":"emitpy/Resource/Equipment/#movements","title":"Movements","text":"<p>A Vehicle has 3 speeds:</p> <ol> <li>Fast, when on service roads, between parking, depots, and apron.</li> <li>Normal, when on an apron.</li> <li>Slow, when closing to the aircraft to/from a service position.</li> </ol>"},{"location":"emitpy/Resource/Ramp/","title":"Ramp","text":"<p>A Ramp is the generic name for a parking for an aircraft. It can either be a parking at a passenger gate, or a \"tie-down\" parking on an remote apron.</p> <p>A Ramp is a resource because it can obviously only be occupied by one aircraft at a time.</p> <p>Ramps are sometimes divided into two or more smaller parking areas.</p> <p>Emitpy does not manage ramp allocation, it only monitors it, reporting a potential issue if a ramp is over used.</p>"},{"location":"emitpy/Resource/Resource/","title":"Resource","text":"<p>A resource is a named entity that maintains a list of usage times (allocations called Reservation).</p> <p>Emitpy maintain the following resources: - Runway - Ramp (or aircraft parking) - Equipement</p> <p>(Aircrafts usage are not managed through resources.)</p> <p>From the collection of existing allocations, it is possible to determine the next time a resource is available.</p>"},{"location":"emitpy/Resource/Resource/#reservation","title":"Reservation","text":"<p>A Reservation is a time slot. It has a start and an end date/time, or a start time and a duration.</p>"},{"location":"emitpy/Resource/Runway/","title":"Runway","text":"<p>Runway allocation is monitored through the Emitpy application. Emitpy does not schedule runway usage, but monitors it.</p> <p>A Runway is \"busy\"</p> <ul> <li>when an aircraft is cleared for landing until it leaves the runway at a runway exit, from about 10 miles out, or 3000ft on final approach,</li> <li>when an aircraft is clear for take-off until it reached a critical point at 1500ft AGL and accelerate.</li> </ul> <p>The monitored usage is theoretical, because based on \"scheduled\" times and not estimated ones.</p>"},{"location":"emitpy/Service/Flight%20Service/","title":"Flight Service","text":"<p>A Flight Service is a collection of Services executed to handle a Flight.</p> <p>For example, an Arrival Flight might need:</p> <ul> <li>Cleaning service,</li> <li>Sewage service,</li> <li>Cargo service to empty the aircraft.</li> </ul> <p>A departing flight might need:</p> <ul> <li>Refueling</li> <li>Catering</li> <li>Cargo service to load the aircraft.</li> </ul>"},{"location":"emitpy/Service/Flight%20Service/#flight-service-scheduling","title":"Flight Service Scheduling","text":"<p>Depending on the type of Flight, Arrival or Departure, services are scheduled relative to the arrival time of the flight, or its scheduled or estimated time of departure.</p> <p>For example:</p> <ul> <li>for an Arrival flight, on a remote parking, cargo offloading is scheduled to start 20 minutes after the aircraft is on block, the service will last 15 minutes.</li> <li>for a Departing flight, the refueling process is scheduled to start 45 minutes before the estimated time of departure, the service will last 15 minutes.</li> </ul> <p></p>"},{"location":"emitpy/Service/Flight%20Service/#flight-service-variables","title":"Flight Service Variables","text":"<p>The collection of services and their timing depends on numerous parameters. In the emitpy application, we limited the dependancy on the following paramters:</p> <ul> <li>Flight Type: Either passenger flight or cargo flight.</li> <li>Aircraft Type: Wide body or narrow body. Mainly affects timing; refueling a A318 does not take the same time as refueling a A380.</li> <li>Ramp Type: Jetway or Tie-Down (!). Used to provide different sets of services, for example mobile staircases may not be necessary if a jetway is available; similarly, it is more likely that a fuel hydrant truck will be used on a jetway and may be some tanker trucks on remote parking location.</li> </ul> <p>Ramp type is always tie-down for cargo flights.</p> <p>Rather than a fixed duration, a flight service profile may also contain a quantity that is used to model the duration of the service, depending on the serving vehicle. For some services (for example Baggage Service), the service quantity is used to determine the number of round trips the baggage trolley will do between the aircraft and the baggage depot. It is also possible to model several baggage trolley only performing one trip, or any combination of the two.</p>"},{"location":"emitpy/Service/Flight%20Service/#turnaround","title":"Turnaround","text":"<p>A Turnaround is a collection of two flight services for an arrival flight followed by a departure flight.</p>"},{"location":"emitpy/Service/Flight%20Service/#aircraft-towing","title":"Aircraft Towing","text":"<p>It is possible to schedule the towing of an aircraft from the arrival ramp to the departure ramp. Arrival Flight Services are performed at the arrival ramp. Departure Flight Services are performed at the departure ramp. (Note: Not integrated in turnaround, but can be scheduled manually.)</p>"},{"location":"emitpy/Service/Ground%20Support/","title":"Ground Support","text":"<p>A Ground Support is an abstract container entity that represents the movement of an airport ground service vehicle or equipment.</p>"},{"location":"emitpy/Service/Ground%20Support/#ground-support-type","title":"Ground Support Type","text":"<p>There are two types of ground support:</p> <ul> <li>Service</li> <li>Mission</li> </ul>"},{"location":"emitpy/Service/Ground%20Support/#ground-support-equipment","title":"(Ground Support) Equipment","text":"<p>The Equipment is used to perform the Ground Support.</p>"},{"location":"emitpy/Service/Ground%20Support/#equipment-type","title":"Equipment Type","text":"<p>An Equipent has a type (Equipment Type) that is associated to the service it allows to perform, and a model that determine its capacties. A Equipment continuously maintain its position. At the start of the emitpy application, the vehicle is located at a  Depot or Parking for that service type.</p>"},{"location":"emitpy/Service/Mission/","title":"Mission","text":"<p>A Mission is a special kind of service vehicle movement. A mission is performed by a Mission Vehicle that has similar behavior as Service Vehicle. A Mission Vehicle starts from its initial position, saved in its internal structure, A Mission Vehicle then go to all checkpoint positions it has been assigned to visit. It stops for a amount of time at each position it reaches. After the last position, it goes to a final position with is a rest area for mission vehicle types.</p> <p>Typical Missions are:</p> <ul> <li>A security vehicle that circulates around the airport to control, for instance, entrance gates.</li> <li>A aviary control vehicle that circulates on runways and taxiways.</li> <li>A fire fighting vehicle that goes to place on fire.</li> <li>A snow plower vehicle running on a runway or taxiway.</li> <li>A grass mower gardening fields between runways.</li> <li>A custom vehicle that circulates between cargo depots.</li> <li>\u2026</li> </ul> <p>Missions are performed with Mission Vehicle Types. A mission consists of a list of positions to visit and an optional final position to reach after completion of the mission.</p>"},{"location":"emitpy/Service/Service%20Event/","title":"Service Event","text":"<p>Events are a special type of aircraft service that does not involve or produce a movement of ground support vehicle.</p> <p>For example, when an aircraft arrives, the following events occur:</p> <ul> <li>First and last passager exits the aircraft,</li> <li>Cabin crew exits the aircraft</li> <li>Cargo doors are open</li> <li>Etc.</li> </ul> <p>All these events can be scheduled and recorded, without producing the movement of a vehicle.</p>"},{"location":"emitpy/Service/Service/","title":"Service","text":"<p>A Service is a container entity that represents the movement of an airport ground service vehicle or equipment.</p>"},{"location":"emitpy/Service/Service/#service-type","title":"Service Type","text":"<p>The Service provided has a core type like Fuel, Catering, Water, Sewage, Pushback, Cargo\u2026</p> <p>The type of service determine the type of vehicle that will be used. A given service can be served by different vehicle model. For example, a Fuel service can be provided by a Hydrant-type of fuel service vehicle when an aircraft is docked at a jetway, or by a Fuel Tanker truck when an aircraft is tied down at a remote parking.</p> <p>The scheduling of the service is either directly supplied at service creation, or planned according to the Flight Service schedule.</p>"},{"location":"emitpy/Service/Service/#equipment","title":"Equipment","text":"<p>The Equipment is used to perform the service.</p>"},{"location":"emitpy/Service/Service/#equipment-type-and-model","title":"Equipment Type and Model","text":"<p>An Equipent has a type (Equipment Type) that is associated to the service it allows to perform, and an equipment (or vehicle) model that determine its capacties. A Equipment continuously maintain its position. At the start of the emitpy application, the vehicle is located at a Service Depot for that service type.</p>"},{"location":"emitpy/Service/Service/#service-depot","title":"Service Depot","text":"<p>A Service Depot is a location from where all service vehicles start. If the service requires visit to the depot, service vehicle movements are created between the depot and the service location (ramp). For example, after servicing one aircraft, the Catering truck heads back to the Catering depot. Service Depots have a type, very much like services: Fuel, Catering, etc. Example of service depots:</p> <ul> <li>Fuel</li> <li>Catering</li> <li>Baggage handling facility</li> </ul> <p>A service of a given type (Baggage) may have more than one depot location.</p>"},{"location":"emitpy/Service/Service/#service-rest-area","title":"Service Rest Area","text":"<p>Service Rest Areas are locations where service vehicles go when they do not serve any aircraft.</p>"},{"location":"emitpy/Service/Service/#service-movement","title":"Service Movement","text":"<p>A Service Movement is the movement of a service vehicle that serves a flight. 1. The movement starts from the \"current position\" of the service vehicle (stored in the vehicle). 2. The service vehicle then goes to its service location on the ramp. The movement occurs on the network of the Managed Airport service roads. The service vehicle stays at the ramp for the duration of the service. 3. The duration of the service is either fixed or dependant on the service quantity. 4. At the enf of the service, the vehicle goes to either a Service Depot or Service Rest Area. This destination is the \"end of service\" position and is maintained in the vehicle. The next time the vehicle is requested for service, it will start from that position.</p> <p></p>"},{"location":"emitpy/Service/Service/#ramp-service-location","title":"Ramp Service Location","text":"<p>A Ramp is a rectangular area that will host an aircraft and service vehicles around the aircraft. The service vehicles stop at very precise locations around the aircraft. For a given Aircraft Type, there is a Ramp Service Location Profile that determine the precise location of the service vehicle relative to the aircraft nose tip. Example of a profile position: 12 meters from nose tip, 4.5 meters on left side, vehicle orientation 70\u00b0 (from aircraft axis). There is such a ramp service position for each service type. If a ramp service location is not found for a given aircraft type, the center of the ramp is used for all service vehicle types.</p> <p></p>"},{"location":"emitpy/Service/Service/#service-duration","title":"Service Duration","text":"<p>The total service duration is composed of - The service setup time - The service time - The service cleanup time (default to the same time as service setup time.)</p> <p>The service time is either fixed (Service always takes the same time, as specified in the Service Type) or dependant on two parameters: A service quantity and a service time per quantity.</p> <p>In addition, a service may require a pause (idle time) before the service starts and another pause after the service ends. During the pause times, the service vehicle remains on a parking area close to the service area.</p>"},{"location":"emitpy/Service/Service/#service-scheduling","title":"Service Scheduling","text":"<p>When the movement of a service vehicle has been created, it is possible to start the movement at any time. The following request is commonly done:</p> <ul> <li>Start a service at a given time</li> <li>End a service at a given time</li> <li>Arrive at ramp at a given time</li> </ul>"},{"location":"emitpy/Service/Service/#service-messages","title":"Service Messages","text":"<p>A Service produces a set of messages:</p> <ol> <li>When the vehicle starts its movement towards the ramp,</li> <li>When the vehicle reaches the ramp,</li> <li>When the service starts,</li> <li>When the service ends,</li> <li>When the vehicle leaves the ramp,</li> <li>When the vehicle stops after leaving the ramp.</li> </ol>"},{"location":"emitpy/Service/Service/#event-service","title":"Event Service","text":"<p>The <code>EventService</code> is a service (of type <code>event</code>) with no vehicle movement associated with it. It is a container for scheduled messages only. The move of the EventService creates messages that will be produced at scheduled time but generate no movement point. Consequently, there is no emission of position points, only emission of messages. The message of the event service is stored in the service <code>event</code> attribute.</p>"},{"location":"emitpy/Utilities/Constants/","title":"Constants","text":"<p>List of constant shared in application.</p>"},{"location":"emitpy/Utilities/Graph/","title":"Graph","text":"<p>Graphs are used when it is necessary to find a Route between two points close to the graph.</p> <ol> <li>Navaids, fixes and airway segments form the Airspace graph.</li> <li>Taxiways and ramps form the Taxiway graph.</li> <li>Service roads, ramps, and points of interest for the Service Road graph.</li> </ol> <p>In emitpy, a Graph is a collection of Vertices (Vertex, a GeoJSON Feature&lt; Point &gt;) and Edges (Edge, a GeoJSON Feature&lt; LineString &gt;). An Edge exposes its extremities (<code>begin</code> and <code>end</code>). Edges are directed.</p> <p>Vertices and Edges have additional properties like the <code>usage</code> property that list one or more use of the vertex or edge.</p> <p>While graph entities remain custom classes in Emitpy, each contain a networkx Graph representation that is used to find routes.</p>"},{"location":"emitpy/Utilities/Graph/#route","title":"Route","text":"<p>A Route is a list of segments (Edges) to go from a source vertex to a destination vertex. Most of the time, the A-Star algorithm is used with the distance used as a heuristic function since all graphs in emitpy are geolocalized.</p>"},{"location":"opera/Areas%20of%20Interest/","title":"Areas of Interest","text":"<p>Opera monitors vehicle movements through areas of interest. Areas of interest are polygons on the ground of the airport. Polygons are named and combined through their class and type identifiers (See below).</p> <p>Here are the typical areas of interest defined in Opera:</p> <ul> <li>Runway</li> <li>Taxiway segment (buffer of <code>taxiway_width</code>  around the 2 point segment)</li> <li>Service road segment  (buffer of <code>service_road_with</code> (contant) around the 2 point segment)</li> <li>Ramp</li> <li>Apron</li> <li>Terminal</li> <li>Service depot</li> <li>GSE Parking</li> <li>Checkpoints</li> <li>Airport areas</li> <li>Aerodrome</li> <li>TMO and more</li> </ul>"},{"location":"opera/Areas%20of%20Interest/#collection-of-areas-of-interest","title":"Collection of Areas of Interest","text":"<p>Individual areas of interest are grouped in \"functional\" categories.</p> <ul> <li>Ramps</li> <li>Taxiways</li> <li>Service roads</li> <li>Aprons</li> <li>GSE Parkings</li> <li>Airport sections</li> </ul> <p>Finally, areas of interest may be grouped by other criteria such as - Frequently visited area - Areas in same vicinity (proximity), like neighboring areas</p>"},{"location":"opera/Areas%20of%20Interest/#area-of-interest-identification-and-grouping","title":"Area of Interest Identification and Grouping","text":"<p>Most, if not all objects in Opera are identified by [[Identity|4 identifiers]]. These identifiers can be used to group and organize areas of interests in collections.</p> <p>For example, the four identifiers can be used as such</p> orgId classId typeId name description airport aeroway runway 34L A runway airport aeroway runway all runways airport aeroway apron all aprons airport aeroway environ TMO Circular zone 10 miles around the airport airport aeroway ramp E17 Aircraft parking E17 airport service depot Catering1 First catering restaurant airport service depot Fuel Main airport fuel depot"},{"location":"opera/Areas%20of%20Interest/#area-of-interest-statistics","title":"Area of Interest Statistics","text":"<p>The following information may be recorded for each area of interest:</p> <ul> <li>Timestamp of last vehicle entering the area</li> <li>Total number of vehicles in area</li> <li>Total number of vehicles traversing the area (during a given timeframe, like 15 minutes, or a moving average of the number of vehicles traversing the area.)</li> </ul>"},{"location":"opera/Opera%20%E2%80%93%20Airport%20Operational%20Effectiveness%20Assessment/","title":"Home","text":"<p>Airport Opera estimate the operational effectiveness of an airport by looking at vehicle ground movements, both aircrafts and ground support equipments.</p> <p>Vehicle ground movements are monitored through Rules. A Rule express a vehicle behaviour to monitor. </p> <p>When a Vehicle follows a Rule, timing and location information is saved, analysed, and compiled in other effectiveness indicators.</p> <p>A very simple example to illustrate the mechanism is a Rule that monitors when an aircraft exists a runway (start of rule) and later stops on a parking ramp (end of rule). The timings of the two events allow for easy calculation of taxi-in time. This value, averaged over several aircrafts, together with other airport variables (runway in use, weather, airline\u2026) create a taxi-in indicator. The variation of the indicator is connected to the effectiveness of the airport. This is a very simple, illustrative indicator. Numerous other indicators are estimated and collectively contribute to the estimation of the operational effectiveness of the airport.</p> <p>(Picture of dashboard here later.)</p>"},{"location":"opera/Rule/","title":"Rules","text":"<p>A Rule correspond to a movement of interest that needs monitoring.</p> <p>A Rule first specifies which vehicles need monitoring and then details which types of movements need reporting. To precise the movements, a Rule uses two Events, a start event that dictates when the monitoring of the movement must start, and an end event when the movement no longer need to be monitored.</p>"},{"location":"opera/Rule/#events","title":"Events","text":"<p>An Event occurs when a vehicle makes an action relative to an Area of Interest. Opera constantly monitor vehicle movements and raises events as they occur.</p>"},{"location":"opera/Rule/#actions","title":"Actions","text":"<p>Possible vehicle actions relative to areas of interest are:</p> <ul> <li>Entering (an area of interest)</li> <li>Leaving (an area of interest)</li> <li>Being stopped inside an area of interest</li> <li>Crossing an area of interest.</li> </ul> <p>Actions are determined on the basis of the penultimate and the last known position of a vehicle. For example, when a vehicle is not in an area of interest in the penultimate position, and inside an area of interest in the last position, we assume the vehicle entered the area of interest.</p> <p>When the position of a vehicle has not changed between reported positions, or when the average reported speed of the vehicle is close to 0, or the relative distance between the two reported positions is small, we assume the vehicle has stopped in the area of interest. </p> <p>Finally, all areas of interest that are intersected by the line joining the penultimate and last positions, we assume they are/were crossed by the vehicle, assuming the vehicle move onto a straight line between the last two points. In practice, the penultimate and last position must be outside the area of interest and the line joining the penultimate and last position must have at least one intersection point with the area of interest.</p> <p></p> <p>For most events, crossing points between vehicle trajectories and areas of interest are recorded and it is possible to determine timing information if necessary.</p>"},{"location":"opera/Rule/#areas-of-interest","title":"Areas of Interest","text":"<p>Areas of interest are polygons on the ground of the airport. They can be as large as the entire airport or as small as a parking location.</p> <p>Areas of interest are named following the same identification mechanism as vehicle, using four attributes. This allow for basic areas of interest grouping, by classes or types.</p> <p>When writing an Event, it is not necessary to supply a single, unique area of interest. It is possible to supply a collection of areas of interest (AoI). The Event will match any AoI that is in the collection.</p>"},{"location":"opera/Rule/#rule","title":"Rule","text":"<p>A Rule is a coordination of two events for a vehicle, or category of vehicle.</p>"},{"location":"opera/Rule/#name","title":"Name","text":"<p>Each Rule has a name for identification purpose. It usually is a serial number. If the name of the Rule starts with <code>#</code>, the Rule is ignored (commented out).</p>"},{"location":"opera/Rule/#vehicles","title":"Vehicles","text":"<p>When writing a Rule, it is not necessary to supply a single, unique vehicle identifier. It is possible to supply a type and/or a class of vehicles. The Rule will match any vehicle that is in the collection. Examples of vehicle classes are aircrafts, or ground support vehicle. Examples of vehicle types are aircraft models or ground support vehicle function like refueling or baggage handling.</p> <p>In a Rule, the vehicle is specified as a regular expression that must match the vehicle identifier.</p>"},{"location":"opera/Rule/#areas-of-interest_1","title":"Areas of Interest","text":"<p>In a Rule, the collection of areas of interest is specified as a regular expression that must match the area of interest identifier.</p>"},{"location":"opera/Rule/#start-and-end-events","title":"Start and End Events","text":"<p>A Rule is defined by two events of interest, a start event and an end event.</p> <p>For example:</p> <ul> <li>Start: When a vehicle exits any runway</li> <li>End: When a vehicle enters any ramp</li> </ul>"},{"location":"opera/Rule/#same-area-of-interest","title":"Same Area Of Interest","text":"<p>This boolean flag indicates whether the area of interest of the start and end event must be exactly the same or not.</p>"},{"location":"opera/Rule/#rule-timeout","title":"Rule Timeout","text":"<p>The rule has a timeout that is started when the start event occurs and determine the time before which the end event must arrive.</p> <p>The timeout is a fine parameter that can be adjusted to generate multiple events when necessary. For exemple, if a vehicle runs back and forth through a area of interest, a long timeout will only capture the first and last traversal of the area of interest in a single promise/resolve pair because the promise will be slow to expire. On the opposite, with a short timeout, each traversal with create a new promise/resolve pair since the previous promise will be expired due to the short timeout.</p>"},{"location":"opera/Rule/#rule-monitoring","title":"Rule Monitoring","text":"<p>Each time a new position arrives, Opera determine the vehicle and monitor whether the vehicle triggers some Events.</p>"},{"location":"opera/Rule/#event-message","title":"Event Message","text":"<p>A vehicle making an action relative to an area of interest produces a Message with:</p> <ul> <li>The vehicle identifier,</li> <li>The position of the vehicle,</li> <li>The time of the event,</li> <li>The action,</li> <li>The area of interest that is involved.</li> </ul> <p>If a triggered event is part of a Rule, the Rule is updated as follow:</p>"},{"location":"opera/Rule/#promise","title":"Promise","text":"<p>When an event matches the start event of a rule, the rule is activated. The rule becomes a promise for a precise vehicle and area of interest.</p>"},{"location":"opera/Rule/#promise-timeout","title":"Promise Timeout","text":"<p>The Rule remains a promise until it times out. The start time of the timeout is reset each time the same start event occurs, for the same vehicle, for the same area of interest, while the promise is not expired.</p> <p>When a Promise has timed out (is expired), it can no longer be resolved nor reset. It is archived. If a new start event arrives for the same vehicle, for the same area of interest, and an previous promise has expired (and has been archived), a new promise is created.</p>"},{"location":"opera/Rule/#resolution","title":"Resolution","text":"<p>When an event matches the end event of a Promise, the rule is resolved. The result of the rule is archived for later processing.</p> <p>The Rule must be resolved by the same vehicle that triggered it.</p> <p>When a rule is resolved, its promise is not removed. The promise remains until it times out.</p>"},{"location":"opera/Rule/#resolved-rule-data","title":"Resolved Rule Data","text":"<p>When a rule is resolved, the following data is stored:</p> <ul> <li>Identifier of the rule,</li> <li>Event data of the promise,</li> <li>Event data of the resolution.</li> </ul> <p>The most valuable data that is retained is the time difference between the promise and the resolve, in other words, the duration of the rule.</p> <p>Other data is used as follow:</p> <p>The vehicle that triggered the rule gives information about actors in the activity. Who is doing what, what activities are going on.</p> <p>The area(s) of interest where the rule occurred gives location information: Where is the activity taking place, what are the areas under stressful situations.</p> <p>The unique combination of actors and areas of activity allow Opera to build an image of all activities running on the ground of the airport.</p>"},{"location":"opera/Vehicle/","title":"Vehicle","text":"<p>A Vehicle is a generic term for a device that moves on the ground of the airport and regularly reports its position. A Vehicle can be a ground support vehicle or an aircraft.</p> <p>When Opera receives a new position, it first identifies the Vehicle that reported its position.</p>"},{"location":"opera/Vehicle/#vehicle-identifier-and-grouping","title":"Vehicle Identifier and Grouping","text":"<p>Most, if not all objects in Opera are identified by [[Identity|4 identifiers]]. These identifiers are used to group and organize objects in collections.</p> <p>For example, for Vehicles, the four identifiers can be used as such:</p> orgId classId typeId name description British Airways C A321 OO-PMA Airbus A321 with ICAO24 registration efface StandardOil fuel hydrant FUEL07 Fuel vehicle ICAO24 aabbcc LAPD Security police POL123 Mission patrol vehicle ICAO24 abacad <p>The combination of these four attributes make the Vehicle Identifier.</p>"},{"location":"opera/Vehicle/#vehicle-attributes","title":"Vehicle Attributes","text":""},{"location":"opera/Vehicle/#key","title":"Key","text":"<p>The key of a vehicle is its ICAO24 ADS-B address in hexadecimal format (6 hexadecimal digits).</p>"},{"location":"opera/Vehicle/#identifier","title":"Identifier","text":"<p>See above.</p> <p>The identifier is used to uniquely identify an object.</p>"},{"location":"opera/Vehicle/#is-aircraft","title":"Is Aircraft","text":"<p>There is a distinction between aircrafts and ground vehicle or personnel.</p>"},{"location":"opera/stats/Indicators/","title":"Indicators","text":"<p>An indicator is a value computed from received positon.</p>"},{"location":"opera/stats/Indicators/#basic-statistical-indicators","title":"Basic Statistical Indicators","text":""},{"location":"opera/stats/Indicators/#number-of-messages-received","title":"Number of messages received","text":"<p>Total number Total number since midnight Flow of message (number per second? minute? hour?)</p>"},{"location":"opera/stats/Indicators/#vehicle","title":"Vehicle","text":""},{"location":"opera/stats/Indicators/#non-aircraft","title":"Non Aircraft","text":"<p>Number of different vehicles (active in last 1 or 3 hours)</p>"},{"location":"opera/stats/Indicators/#aircraft","title":"Aircraft","text":"<p>Number of aircraft (active in last 1 or 3 hours) Number of arrival (completed in last 3 hours, in next 30 minutes, 1 h, 2h, 3h, 6h) Number of departure (completed in last 3 hours, in next 30 minutes, 1 h, 2h, 3h, 6h)</p>"},{"location":"opera/stats/Indicators/#movements","title":"Movements","text":""},{"location":"opera/stats/Indicators/#aircraft_1","title":"Aircraft","text":"<p>Average taxi-in time Average taxi-out time Average time on ramp, exclude outliers (more than 4 or 6 hours)</p>"},{"location":"opera/stats/Indicators/#non-aircraf","title":"Non Aircraf","text":""},{"location":"opera/stats/Maps/","title":"Heatmap","text":"<p>Presence of vehicle on the ground of the airport, very much like a street map with traffic information.</p>"},{"location":"opera/stats/Maps/#h3","title":"H3","text":"<p>Heatmap can easily be produced from H3 indices. The resolution of the indices will determine the precision of the map.</p>"}]}